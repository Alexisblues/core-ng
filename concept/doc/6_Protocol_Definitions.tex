\chapter{Protocol Definitions}

\section{Microservices API}
\label{protocoldef:microservicesapi}
\todo{define all the REST / WS Interfaces}
See \hyperref[internalprog:microservices]{Microservices definition}.

\subsection{Database Service}
\subsubsection{* /users/*}

\subsubsection{* /nodes/*}

\subsubsection{* /rubrics/*}

\subsubsection{* /subscribers/*}

\subsubsection{* /subscriber\_groups/*}

\subsubsection{DELETE /transmitters/:id}

\subsubsection{PUT /transmitters}


\subsection{Call Service}

\subsubsection{* /calls/*}


\subsection{Rubric Service}

\subsubsection{* /rubrics/:id/*}


\subsection{Transmitter Service}

\subsubsection{GET /transmitters}

\subsubsection{GET /transmitters/:id}

\subsubsection{GET /transmitters/:id}

\subsubsection{POST /transmitters/bootstrap}
\label{protcoldef:transmitters:bootstrap}
\texttt{POST /transmitter/bootstrap}
\begin{lstlisting}
{
  "callsign": "db0avr",
  "auth_key": "<secret>",
  "software": {
    "name": "UniPager",
    "version": "1.0.2"
  }
}
\end{lstlisting}

\textbf{Answers to the bootstrap REST call}

\texttt{200 OK}
\begin{lstlisting}
{
  "timeslots": [true, true, false, true, ...],
  "nodes": [
    {
      "host": "node1.ampr.org",
      "port": 4000,
      "reachable": true,
      "last_seen": "2018-07-03T07:43:52.783611Z",
      "response_time": 42
    }
  ]
}
\end{lstlisting}

\texttt{423 Locked}
\begin{lstlisting}
{
  "error": "Transmitter temporarily disabled by config."
}
\end{lstlisting}

\texttt{423 Locked}
\begin{lstlisting}
{
  "error": "Transmitter software type not allowed due to serious bug."
}
\end{lstlisting}


\subsubsection{POST /transmitters/heartbeat}
\texttt{POST /transmitter/heartbeat}
\begin{lstlisting}
{
  "callsign": "db0avr",
  "auth_key": "<secret>",
  "ntp_synced": true
}
\end{lstlisting}

\textbf{Answers to the heartbeat REST call}
\texttt{200 OK}
\begin{lstlisting}
{
  "status": "ok"
}
\end{lstlisting}

If network wants to assign new timeslots without disconnecting (for dynamic timeslots)

\texttt{200 OK}
\begin{lstlisting}
{
  "status": "ok",
  "timeslots": [true, true, false, ...],
  "valid_from": "2018-07-03T08:00:52.786458Z"
}
\end{lstlisting}

If network wants to initiate handover to other node

\texttt{503 Service unavailable}
\begin{lstlisting}
{
  "error": "Node not available, switch to other node."
}
\end{lstlisting}


\subsection{Cluster Service}

\subsubsection{POST /cluster/discovery}


\subsection{Telemetry Service}

\subsubsection{GET /telemetry/*}

\subsubsection{WS /telemetry}


\subsection{Database Changes Service}

\subsubsection{WS /changes}


\subsection{Status Service}
The purpose of the status service is to provide a short overview of the DAPNET network and the microservices.

\subsubsection{GET /status}
\texttt{200 OK}
\begin{lstlisting}
{
  "good_health" : true,
  "version" : "1.2.3"
  "microservices\_running" : {
    "database" : true,
    "call" : true,
    "rubric" : true,
    "transmitter" : true,
    "cluster" : true,
    "telemetry" : true,
    "database-changes" : true,
    "statistics" : true,
    "rabbitmq" : true,
    "thirdparty" : true
  }
}
\end{lstlisting}

\subsubsection{GET /status/<service\_name>}
List of valid values for \textit{service\_name}:

database-service\\
call-service\\
rubric-service\\
transmitter-service\\
cluster-service\\
telemetry-service\\
database-changes-service\\
statistics-service\\
rabbitmq-service\\


\texttt{200 OK}
\begin{lstlisting}
<Status output from service itself>
\end{lstlisting}


\subsection{Statistics Service}

\subsubsection{GET /statistics}


\subsection{RabbitMQ Service}

\subsubsection{GET /rabbitmq/*}


\section{RabbitMQ}
\label{protocoldef:RabbitMQ}
There are 3 exchanges available on each RabbitMQ instance:
\begin{description}
\item[dapnet.calls] Messages shared between all nodes
\item[dapnet.local\_calls] Messages coming from the local node instance
\item[dapnet.telemetry] Messages containing telemetry from transmitters
\end{description}


\subsection{Transmitters}
\label{protocoldef:RabbitMQ:Transmitters}

Valid Messages are:

\subsubsection{dapnet.calls}
\label{protocoldef:RabbitMQ:dapnet.calls}
The messages to transfer data to be transmitted by the transmitter have the
following format.

For each transmission, there is a separate RabbitMQ message, as different
receivers might need different text encoding. All encoding is already done, when
this message is created. The transmitter does no character encoding at all. Both
personal pagings and rubric related messages are transmitted with this protocol.

\begin{lstlisting}
{
  "id": "016c25fd-70e0-56fe-9d1a-56e80fa20b82",
  "protocol": "POCSAG",
  "priority": 3,
  "expires": "2018-07-03T08:00:52.786458Z",
  "message": {
    "ric": 12342,
    "subric": 0 to 3,
    "type": "ALPHANUM",
    "speed": 1200,
    "function": 3,
    "data": "Lorem ipsum dolor sit amet"
  }
}
\end{lstlisting}
The selection of the transmitter is done by means of the routing key. Besides,
the priority is also used in the RabbitMQ queuing to deliver higher priority
messages first.

\subsubsection{dapnet.local\_calls}
\label{protocoldef:RabbitMQ:dapnet.local_calls}
Same as for the the network originated calls in section \ref{protocoldef:RabbitMQ:dapnet.calls}.

\subsection{Telemetry}
On the telemetry exchange, all transmitters and nodes publish their telemetry messages. The format the same as in section \ref{protocoldef:telemetrytx} and \ref{protocoldef:telemetrynodes}.

\subsection{MQTT API for third-party consumers}
\label{protocoldef:mqttapi}
In order to allow third-party instances like \href{http://www.aprs-is.net/|APRS}, \href{http://brandmeister.network|Brandmeister} or others to get the emitted calls and rubric contents in a real time event driven way, there is an MQTT API. It is not implemented via a dedicated MQTT broker, but uses the existing RabbitMQ instance (\url{https://www.rabbitmq.com/mqtt.html}. There is no distribution of the messages via this MQTT broker; it is local only. So every node publishes the messages locally on its own.
\todo{check with DL2IC}
Each subscriber has an array of enabled third-party applications. This allow to define the user, if call directed to her/his subscriber shall be also sent to third-party services (see \ref{protocoldef:couchdb:subscribers}.

The currently existing MQTT topics are defined in the CouchDB (see section \ref{protocoldef:couchdb:mqttservicesandsubscribers}). This makes it possible to add more third-party services and authorized users during runtime without the need to update the software.
The valid users to subscribe to the topic are also listed in the same CouchDB database.

The only permitted access for third-party consumers is read. So the subscribe request from a third-party MQTT-Client must use authentication which is checks against the CouchDB data. If correct, read access is granted. Core software has always write access to publish the calls group messages.

The transmitters who are supposed to send out the personal call or the rubric content are published with callsign, geographic location and type of transmitter (widerange or personal). With this generic concept, every third-party application can decide what to do with the content received.

The encoding of the data is UTF-8.

The format of the data published for \textbf{personal paging calls} is
\begin{lstlisting}
{
  "pagingcall" : {
    "srccallsign" : "dl2ic",
    "dstcallsign" : "dh3wr",
    "dstric" : 12344,
    "dstsubric" : 0 ... 3,
    "priority" : 3,
    "message" : "DAPNET 2.0 rocks dear YL/OM"
    "transmitted_by" : [
      {
        "callsign" : "db0abc",
        "lat" : 12.123456,
        "long" : 32.123456,
        "type" : "PERONAL" | "WIDERANGE"
      },
      {
        "callsign" : "db0def",
        "lat" : 12.123456,
        "long" : 32.123456,
        "type" : "PERONAL" | "WIDERANGE"
      }
    ],
    "timestamp" : <TIMESTAMP>
  }
}
\end{lstlisting}

The format of the data published for \textbf{rubric\_content paging calls} is
\begin{lstlisting}
{
  "rubricmessage" : {
    "message" : ""
    "transmitted_by" : [
      {
        "callsign" : "db0abc",
        "lat" : 12.123456,
        "long" : 32.123456,
        "type" : "PERONAL" | "WIDERANGE"
      },
      {
        "callsign" : "db0def",
        "lat" : 12.123456,
        "long" : 32.123456,
        "type" : "PERONAL" | "WIDERANGE"
      }
    ],
    "timestamp" : <TIMESTAMP>
  }
}
\end{lstlisting}

\section{Telemetry from Transmitters}
\label{protocoldef:telemetrytx}
Telemetry is sent from transmitters to the RabbitMQ exchange
\textbf{dapnet.telemetry} as defined in section \ref{protocoldef:RabbitMQ}. It
is also used in the same way on the websocket API to inform the website and the
app about the telemetry in real-time in section
\ref{protcoldef:websocketapi:telemetrytxsummary} and \ref{protcoldef:websocketapi:telemetrytxdetail}.

This is sent every minute in complete. If there are changes, just a subset is sent.
The name of the transmitter is used as routing key for the message.

\begin{lstlisting}
{
  "onair": true,
  "node": {
    "name": "db0xyz",
    "ip": "44.42.23.8",
    "port": 1234,
    "connected": true,
    "connected_since": "<timestamp-format>"
   },
  "ntp": {
    "synced": true,
    "offset": 124,
    "server": ["134.130.4.1", "12.2.3.2"],
  },
  "messages": {
    "queued": [123, 123, 123, 123, 123, 123],
    "sent": [123, 123, 123 , 123, 123, 123]
  },
  "temperatures": {
    "unit": "C" | "F" | "K",
    "air_inlet": 12.2,
    "air_outlet": 14.2,
    "transmitter": 42.2,
    "power_amplifier": 45.2,
    "cpu": 93.2,
    "power_supply": 32.4,
    "custom": [
      {"value": 12.2, "description": "Aircon Inlet"},
      {"value": 16.2, "description": "Aircon Outlet"},
      {"value": 12.3, "description": "Fridge Next to Programmer"}
    ]
  },
  "power_supply": {
    "on_battery": false,
    "on_emergency_power": false,
    "dc_input_voltage": 12.4,
    "dc_input_current": 3.23
  },
  "rf_output" : {
    "fwd": 12.2,
    "refl" : 12.2,
    "vswr" : 1.2
  },
  "config": {
    "ip": "123.4.3.2",
    "timeslots" : [true, false,...,	false],
    "software": {
      name: "Unipager" | "MMDVM" | "DAPNET-Proxy",
      version: "v1.2.3", | "20180504" | "v2.3.4",
    },
  }
  "hardware": {
    "platform": "Raspberry Pi 3B+"
  },
  "rf_hardware": {
    "c9000": {
      "name" : "C9000 Compact",
      "<pa_dummy>" : {
        "output_power" : 123,
        "port" : "/dev/ttyUSB0"
      }
      "<rpc>": {
        "version" : "XOS/2.23pre"
      }
    },
    "raspager": {
      "name": Raspager",
      "modulation": 13,
      "power": 63,
      "external_pa": false,
      "version": "V2"
    },
    "audio": {
      "name" = "Audio",
      "transmitter": "GM1200" | "T7F" | "GM340" | "FREITEXT",
      "audio_level": 83,
      "tx_delay": 3
    },
    "rfm69": {
      "name" : "RFM69",
      "port": "/dev/ttyUSB0"
    },
    "mmdvm": {
      "name" : "MMDVM",
      "dapnet_exclusive": true
    }
  },
  "proxy" : {
    "status": "connected" | "connecting" | "disconnected"
  }
}
\end{lstlisting}

\section{Telemetry from Nodes}
\label{protocoldef:telemetrynodes}
Telemetry is sent from nodes to the RabbitMQ exchange
\textbf{dapnet.telemetry} as defined in section \ref{protocoldef:RabbitMQ}. It
is also used in the same way on the websocket API to inform the website and the
app about the telemetry in real-time in section
\ref{protcoldef:websocketapi:telemetrynodessummary} and \ref{protcoldef:websocketapi:telemetrynodesdetail}.

This is sent every minute in complete. If there are changes, just a subset is sent.
The name of the nodes is used as routing key for the message.
\begin{lstlisting}
{
  "good_health" : true,
  "microservices" : {
    "database" : {
      "ok" : true,
      "version" : "1.2.3"
    },
    "call" : {
      "ok" : true,
      "version" : "1.2.3"
    },
    "rubric" :  {
      "ok" : true,
      "version" : "1.2.3"
    },
    "transmitter" :  {
      "ok" : true,
      "version" : "1.2.3"
    },
    "cluster" :  {
      "ok" : true,
      "version" : "1.2.3"
    },
    "telemetry" : {
      "ok" : true,
      "version" : "1.2.3"
    },
    "database-changes" :  {
      "ok" : true,
      "version" : "1.2.3"
    },
    "statistics" :  {
      "ok" : true,
      "version" : "1.2.3"
    },
    "rabbitmq" :  {
      "ok" : true,
      "version" : "1.2.3"
    },
    "thirdparty" :  {
      "ok" : true,
      "version" : "1.2.3"
    },
  },
  "connections" : {
    "transmitters" : 123,
    "third_party" : 3
  },
  "system" : {
    "free_disk_space_mb": 1234
    "cpu_utilization": 0.2
    "is_hamcloud" : false
  }
}
\end{lstlisting}

\section{Statistic, Status and Telemetry REST API}
The statistic and telemetry REST API provides up-to-date information regarding the transmitters and the network via REST. This can be used by e.g. grafana to draw nice graphes or nagios plugins.


\subsection{Statistics}
Statistics are given in JSON with number values only to may parsing easier.

\texttt{GET /stats}

No authentication required.

Answer:
\texttt{200 OK}
\begin{lstlisting}
{
  "users" : 1234,
  "transmitters": {
    "personal": {
      "online": 13
      "total": 34
    },
    "widerage": {
      "online": 53,
      "total": 97
    }
  }
  "nodes": {
    "online": 10,
    "total": 19
  },
  "processed_calls": 1234,
  "processed_rubric_content_changes": 234
}
\end{lstlisting}

\todo{On the calls and rubric content changes: Always increasing counter link traffic on network device or reset at 00:00 am?}

\subsection{Status}
\texttt{GET /status}

No authentication required.

Answer:
\texttt{200 OK}
\begin{lstlisting}
{
  "nodes": [
    {
      "host": "node1.ampr.org",
      "port": 4000,
      "reachable": true,
      "last_seen": "2018-07-03T07:43:52.783611Z",
      "response_time": 42
    }
  ],
  "connections": {
    "rabbitmq": true,
    "couchdb": true,
    "hamcloud": true,
  },
  "hamcloud_node": false,
  "general_health": true
}
\end{lstlisting}

\subsection{Telemetry from Transmitters}

\texttt{GET /telemetry/transmitter}

No authentication required. Here all stored telemetry from all transmitters is provided.

Answer:
\texttt{200 OK}
See \ref{protocoldef:telemetrytx}\\\\

\texttt{GET /telemetry/transmitter/<transmittername>}

No authentication required. Here all stored telemetry from the specified transmitter is provided.

Answer:
\texttt{200 OK}

See \ref{protocoldef:telemetrytx}\\\\

\texttt{GET /telemetry/transmitter/<transmittername>/<section\_of\_telemetry>}

No authentication required. Here all stored telemetry within the telemetry
section from the specified transmitter is provided. Possible sections are 2.
Level JSON groups, see \ref{protocoldef:telemetrytx}.

Examples: onair, telemetry, transmitter\_configuration

Answer:
\texttt{200 OK}

See \ref{protocoldef:telemetrytx}

\subsection{Telemetry from Nodes}

\texttt{GET /telemetry/nodes}

No authentication required. Here all stored telemetry from all nodes is provided.

Answer:
\texttt{200 OK}
See \ref{protocoldef:telemetrynodes}\\\\

\texttt{GET /telemetry/nodes/<nodename>}

No authentication required. Here all stored telemetry from the specified node is provided.

Answer:
\texttt{200 OK}

See \ref{protocoldef:telemetrynodes}\\\\


\section{Websocket API}
\label{protocoldef:websocketapi}
The idea is to provide an API for the website and the app to display real-time
information without the need of polling. A websocket server is listing to
websocket connections. Authentication is done by a custom JOSN handshake. The
connection might be encrypted with SSL if using the Internet or plain if using
HAMNET.

The data is taken from the \textbf{dapnet.telemetry} exchange
from the RabbitMQ instance and further other sources if necessary.

\todo{Define if authentication is necessary of some endpoints?}

There are 4 main endpoints in the websocket interface:


\begin{center}
  \begin{tabular}{|l|l|} \hline
    Endpoint & Microservice \\ \hline \hline
    \verb|WS     /telemetry/transmitters| & Summary data of all TX \\ \hline
    \verb|WS     /telemetry/transmitters/<TxName>| & Details for TX <TxName>\\ \hline
    \verb|WS     /telemetry/nodes| & Summary data of all Nodes\\ \hline
    \verb|WS     /telemetry/nodes/<NodeName>| & Details for Node <NodeName>\\ \hline
    \verb|WS     /changes| & Database changes\\ \hline

  \end{tabular}
\end{center}


\subsection{Telemetry from Transmitters - Summary of all TX}
\label{protcoldef:websocketapi:telemetrytxsummary}
URL: \texttt{ws://FQDN/telemetry/transmitters}\\\\

The data is the same as received from the \textbf{dapnet.telemetry} exchange
from the RabbitMQ instance. It is defined in section
\ref{protocoldef:telemetrytx}.\\
The websocket-Server generates an array of JSON Objects which have the name of the transmitter obtained from the RabbitMQ routing key.\\
The current time slot is also sent in the summary and updated also by its own every time a time slot change happens.

\begin{lstlisting}
{
  "transmitters": [
    "db0abc" : {
      "onair": true,
      "node": {
        "name": "db0xyz",
        "ip": "44.42.23.8",
        "port": 1234,
        "connected": true,
        "connected_since": "<timestamp-format>"
       },
      "ntp": {
        "synced": true
      },
      "messages": {
        "queued": [123, 123, 123, 123, 123, 123],
        "sent": [123, 123, 123 , 123, 123, 123]
      },
      "config": {
        "ip": "123.4.3.2",
        "timeslots" : [true, false,...,	false],
      "software": {
        name: "Unipager" | "MMDVM" | "DAPNET-Proxy",
        version: "v1.2.3", | "20180504" | "v2.3.4"
      },
      "proxy" : {
        "status": "connected" | "connecting" | "disconnected"
      }
    },
    "db0xyz" : {
      "onair": true,
      "node": {
    ....
    }        
  ],
  "current_timeslot" : 12
}
\end{lstlisting}

\subsection{Telemetry from Transmitters - Details of Transmitter}
\label{protcoldef:websocketapi:telemetrytxdetail}
URL: \texttt{ws://FQDN/telemetry/transmitters/<transmittername>}\\\\

The data is the same as received from the \textbf{dapnet.telemetry} exchange
from the RabbitMQ instance. It is defined in section
\ref{protocoldef:telemetrytx}.\\
The websocket-Server gives out all the telemetry data from a certain transmitter. The name of the transmitter obtained from the RabbitMQ routing key. 

\begin{lstlisting}
{
  "onair": true,
  "node": {
  "ip": "44.42.23.8",
    "port": 1234,
    "connected": true,
    "connected_since": "<timestamp-format>"
  },
  "ntp": {
    "synced": true,
    "offset": 124,
    "server": ["134.130.4.1", "12.2.3.2"],
  },
  "messages": {
    "queued": [123, 123, 123, 123, 123, 123],
    "sent": [123, 123, 123 , 123, 123, 123]
  },
  "temperatures": {
    "unit": "C" | "F" | "K",
    "air_inlet": 12.2,
    "air_outlet": 14.2,
    "transmitter": 42.2,
    "power_amplifier": 45.2,
    "cpu": 93.2,
    "power_supply": 32.4,
    "custom": [
      {"value": 12.2, "description": "Aircon Inlet"},
      {"value": 16.2, "description": "Aircon Outlet"},
      {"value": 12.3, "description": "Fridge Next to Programmer"}
    ]
  },
  "power_supply": {
    "on_battery": false,
    "on_emergency_power": false,
    "dc_input_voltage": 12.4,
    "dc_input_current": 3.23
  },
  "rf_output" : {
    "fwd": 12.2,
    "refl" : 12.2,
    "vswr" : 1.2
  },
  "config": {
    "ip": "123.4.3.2",
    "timeslots" : [true, false,...,	false],
    "software": {
      name: "Unipager" | "MMDVM" | "DAPNET-Proxy",
      version: "v1.2.3", | "20180504" | "v2.3.4",
    },
  }
  "hardware": {
    "platform": "Raspberry Pi 3B+"
  },
  "rf_hardware": {
    "c9000": {
      "name" : "C9000 Compact",
      "<pa_dummy>" : {
        "output_power" : 123,
        "port" : "/dev/ttyUSB0"
      }
      "<rpc>": {
        "version" : "XOS/2.23pre"
      }
    },
    "raspager": {
      "name": Raspager",
      "modulation": 13,
      "power": 63,
      "external_pa": false,
      "version": "V2"
    },
    "audio": {
      "name" = "Audio",
      "transmitter": "GM1200" | "T7F" | "GM340" | "FREITEXT",
      "audio_level": 83,
      "tx_delay": 3
    },
    "rfm69": {
      "name" : "RFM69",
      "port": "/dev/ttyUSB0"
    },
    "mmdvm": {
      "name" : "MMDVM",
      "dapnet_exclusive": true
    }
  },
  "proxy" : {
    "status": "connected" | "connecting" | "disconnected"
  }
}
\end{lstlisting}

\subsection{Telemetry from Nodes - Summary of all Nodes}
\label{protcoldef:websocketapi:telemetrynodessummary}
URL: \texttt{ws://FQDN/telemetry/nodes}\\\\

The websocket-Server generates an array of JSON Objects which have the name of the node obtained from the RabbitMQ routing key.

\begin{lstlisting}
{
  "nodes" : [
    "db0sda" : {
      "good_health" : true,
      "connections" : {
        "transmitters" : 123,
        "third_party" : 3
      },
      "system" : {
        "is_hamcloud" : false
      }
    },
    "hamcloud1" : {
      "good_health" : true,
      "connections" : {
        "transmitters" : 658,
        "third_party" : 25
      },
      "system" : {
        "is_hamcloud" : true
      }
    },
    ....
  ]
}
\end{lstlisting}

\subsection{Telemetry from Transmitters - Details of Node}
\label{protcoldef:websocketapi:telemetrynodesdetail}
URL: \texttt{ws://FQDN/telemetry/nodess/<nodename>}\\\\

The data is the same as received from the \textbf{dapnet.telemetry} exchange
from the RabbitMQ instance. It is defined in section
\ref{protocoldef:telemetrytx}.\\
The websocket-Server gives out all the telemetry data from a certain node. The name of the transmitter obtained from the RabbitMQ routing key. 

\begin{lstlisting}
{
  "good_health" : true,
  "microservices" : {
    "database" : {
      "ok" : true,
      "version" : "1.2.3"
    },
    "call" : {
      "ok" : true,
      "version" : "1.2.3"
    },
    "rubric" :  {
      "ok" : true,
      "version" : "1.2.3"
    },
    "transmitter" :  {
      "ok" : true,
      "version" : "1.2.3"
    },
    "cluster" :  {
      "ok" : true,
      "version" : "1.2.3"
    },
    "telemetry" : {
      "ok" : true,
      "version" : "1.2.3"
    },
    "database-changes" :  {
      "ok" : true,
      "version" : "1.2.3"
    },
    "statistics" :  {
      "ok" : true,
      "version" : "1.2.3"
    },
    "rabbitmq" :  {
      "ok" : true,
      "version" : "1.2.3"
    },
    "thirdparty" :  {
      "ok" : true,
      "version" : "1.2.3"
    },
  },
  "connections" : {
    "transmitters" : 123,
    "third_party" : 3
  },
  "system" : {
    "free_disk_space_mb": 1234
    "cpu_utilization": 0.2
    "is_hamcloud" : false
  }
}
\end{lstlisting}

\subsection{Database Changes}
\label{protcoldef:websocketapi:databasechanges}
URL: \texttt{ws://FQDN/changes}\\

To inform the website or the app about changes in the CouchDB database, the
websocket microservice keeps a connection to the local CouchDB API and receives
a stream of updated to the database. As there may be data in the changes that
are confidential, the stream is parsed and sent out in a reduced form to the
websocket client. Further information:
\url{http://docs.couchdb.org/en/2.0.0/api/database/changes.html}

The format of the updates is:

\todo{define/review format}

\subsubsection{Transmitter related}
\texttt{New transmitter added}

\begin{lstlisting}
{
  "type": "transmitter",
  "action" : "added",
  "name": "db0abc",
  "data" : {
  (Data from CouchDB Change feed in processed way)
  }
}
\end{lstlisting}

\texttt{Existing transmitter changed}
\begin{lstlisting}
{
  "type": "transmitter",
  "action" : "changed",
  "name": "db0abc",
  "data" : {
  (Data from CouchDB Change feed in processed way)
  }
}
\end{lstlisting}

\texttt{Transmitter deleted}
\begin{lstlisting}
{
  "type": "transmitter",
  "action" : "deleted",
  "name": "db0abc"
\end{lstlisting}

\subsubsection{User related}
\texttt{New User added}
\begin{lstlisting}
{
  "type": "user",
  "action" : "added",
  "name": "db1abc",
  "data" : {
  (Data from CouchDB Change feed in processed way)
  }
}
\end{lstlisting}

\texttt{Existing user changed}
\begin{lstlisting}
{
  "type": "user",
  "action" : "changed",
  "name": "db1abc",
  "data" : {
  (Data from CouchDB Change feed in processed way)
  }
}
\end{lstlisting}

\texttt{User deleted}
\begin{lstlisting}
{
  "type": "user",
  "action" : "deleted",
  "name": "db1abc"
}
\end{lstlisting}


\subsubsection{Rubric related}
\texttt{New Rubric added}
\begin{lstlisting}
{
  "type": "rubric",
  "action" : "added",
  "id": "...",
  "data" : {
  (Data from CouchDB Change feed in processed way)
  }
}
\end{lstlisting}

\texttt{Existing rubric changed}
\begin{lstlisting}
{
  "type": "user",
  "action" : "changed",
  "id": "...",
  "data" : {
  (Data from CouchDB Change feed in processed way)
  }
}
\end{lstlisting}

\texttt{Rubric deleted}
\begin{lstlisting}
{
  "type": "user",
  "action" : "deleted",
  "id": "..."
}
\end{lstlisting}

\subsubsection{Rubric content related}
\todo{Check against CouchDB structure}

\texttt{New Rubric content added}
\begin{lstlisting}
{
  "type": "rubric_content",
  "action" : "added",
  "id": "...??",
  "data" : {
  (Complete Data dump of all ten rubric messages as stored in CouchDB)
  }
}
\end{lstlisting}

\texttt{Existing rubric changed}
\begin{lstlisting}
{
  "type": "rubric_content",
  "action" : "changed",
  "id": "...",
  "data" : {
  (Complete Data dump of all ten rubric messages as stored in CouchDB)
  }
}
\end{lstlisting}

\texttt{Rubric content deleted}
\begin{lstlisting}
{
  "type": "rubric_content",
  "action" : "deleted",
  "id": "..."
  "data" : {
  (Complete Data dump of all ten rubric messages as stored in CouchDB, some may be empty)
  }
}
\end{lstlisting}


\subsubsection{Node related}
\texttt{New node added}
\begin{lstlisting}
{
  "type": "node",
  "action" : "added",
  "name": "db0abc",
  "data" : {
  (Data from CouchDB Change feed in processed way)
  }
}
\end{lstlisting}

\texttt{Existing node changed}
\begin{lstlisting}
{
  "type": "node",
  "action" : "changed",
  "name": "db0abc",
  "data" : {
  (Data from CouchDB Change feed in processed way)
  }
}
\end{lstlisting}

\texttt{Node deleted}
\begin{lstlisting}
{
  "type": "node",
  "action" : "deleted",
  "name": "db1abc"
}
\end{lstlisting}


\section{CouchDB Documents and Structure}
\todo{als Tabelle darstellen}

\subsection{Users}

\begin{table}[h]
 \centering
 \caption{CouchDB: Users}
 \begin{tabular}{|l|l|l|l|} \hline
  Key & Value-Type & Valid Value Range & Example \\
  \hline
  \_id & string & & dl1abc \\
  password & string & bcrypt hash & --- \\
  email & string & & dl1abc@darc.de \\
  admin & boolean & & true \\
  enabled & boolean & & true \\
  created\_on & string & ISO8601 & 2018-07-08T11:50:02.168325Z \\
  changed\_on & string & ISO8601 & 2018-07-08T11:50:02.168325Z \\
  changed\_by & string & valid user name & dh3wr \\
  email\_valid & boolean & & true \\
  avatar\_picture & couchdb\_attachment & & \\ \hline
  \end{tabular}
  \label{tab:couchdb:users}
\end{table}

\begin{lstlisting}
{
  "_id": "dl1abc",
  "password": "<bcrypt hash>",
  "email": "dl1abc@darc.de",
  "admin": true,
  "enabled": true,
  "created_on": <DATETIME>,
  "created_by":"dh3wr",
  "changed_on": <DATETIME>,
  "changed_by":"dh3wr",
  "email_valid": true
  "avatar_picture": <couchdb attachment>
}
\end{lstlisting}

\todo{Wofür genau braucht man email\_valid?}

\subsection{Nodes}
\begin{table}[h]
 \caption{CouchDB: Nodes}
 \begin{tabular}{|l|l|l|l|} \hline
  Key & Value-Type & Valid Value Range & Example \\
  \hline
  \_id & STRING & N/A & db0abc \\
  coordinates & [number; 2]  & [lat, lon] & [34.123456, 6.23144] \\
  hamcloud & boolean & true/false & true \\
  created\_on & string & ISO8601 & 2018-07-08T11:50:02.168325Z \\
  changed\_by & string & valid user name & dh3wr \\
  changed\_on & string & ISO8601 & 2018-07-08T11:50:02.168325Z \\
  changed\_by & string & valid user name & dh3wr \\
  owners & [string] & N/A & ["dl1abc","dh3wr","dl2ic"] \\
  avatar\_picture & couchdb\_attachment & & \\ \hline
  \end{tabular}
  \label{tab:couchdb:nodes}
\end{table}

\begin{lstlisting}
{
  "_id": "db0abc",
  "auth_key": "super_secret_key",
  "coordinates": [34.123456, -23.123456],
  "hamcloud": true,
  "created_on": <DATETIME>,
  "created_by":"dh3wr",
  "changed_on": <DATETIME>,
  "changed_by":"dh3wr",
  "owners": ["dl1abc","dh3wr","dl2ic"],
  "avatar_picture": <couchdb attachment??>
}
\end{lstlisting}

\subsection{Transmitters}
\todo{Tabelle weiter machen}
\begin{table}[h]
 \caption{CouchDB: Transmitters}
 \begin{tabular}{|l|l|l|l|}\hline
  Key & Value-Type & Valid Value Range & Example \\
  \hline
  \_id & string & N/A & db0abc \\
  auth\_key & string & N/A & asd2FD3q3rF \\
  enabled & boolean & true/false & true \\
  usage & string & PERSONAL | WIDERANGE & WIDERANGE \\
  coordinates & [number; 2]  & [lat, lon] & [34.123456, 6.23144] \\
  power & number & 0.001 ...  & 12.3 \\
  created\_on & string & ISO8601 & 2018-07-08T11:50:02.168325Z \\
  changed\_by & string & valid user name & dh3wr \\
  changed\_on & string & ISO8601 & 2018-07-08T11:50:02.168325Z \\
  changed\_by & string & valid user name & dh3wr \\
  owners & ARRAY of STRING & N/A & ["dl1abc","dh3wr","dl2ic"] \\
  avatar\_picture & couchdb\_attachment & & \\ \hline
  \end{tabular}
  \label{tab:couchdb:transmitters}
\end{table}

\begin{lstlisting}
{
  "_id": "db0abc",
  "auth_key": "hdjaskhdlj",
  "enabled": true,
  "usage": "PERSONAL" | "WIDERANGE",
  "coordinates": [34.123456, -23.123456],
  "power": 12.3,
  "antenna": {
    "agl": 23.4,
    "gain": 2.34,
    "type": "OMNI" | DIRECTIONAL,
    "direction": 123.2,
    "cable_loss": 4.2
  }
  "owners" : ["dl1abc","dh3wr","dl2ic"],
  "groups" : ["dl-hh", "dl-all"],
  "emergency_power": {
    "available": false,
    "infinite": false,
    "duration": 23*60*60 // seconds
  },
  "created_on": <DATETIME>,
  "created_by":"dh3wr",
  "changed_on": <DATETIME>,
  "changed_by":"dh3wr",
  "aprs_broadcast": false,
  "antenna_pattern" : <couchDB attachment>,
  "avatar_picture" : <couchDB attachment>
}
\end{lstlisting}


\subsection{Subscribers}
\label{protocoldef:couchdb:subscribers}
\todo{check if [] is valid JSON}
\begin{lstlisting}
{
  "_id" : "dl1abc",
  "description" : "Peter",
  "pagers" : [
    {
      "ric": 123456,
      "subric": 0 .. 3,
      "uuid": "0023-1233-aefe-1234-3423-9812",
      "name": "Peters Alphapoc",
      "type" : "UNKNOWN" | "Skyper" | "AlphaPoc" | "QUIX" | "Swissphone" | "SCALL_XT" | "Birdy"
      "enabled" : true
    },
    ...
  ],
  "third_party_services" : ["APRS", "BM"],
  "owner": ["dh3wr", "dl1abc"]
}
\end{lstlisting}

\subsection{Subscriber Groups}

\begin{lstlisting}
{
  "_id" : "ov-G01",
  "description": "Ortverband Aachen",
  "subscribers": ["dl1abc", "dh3wr"],
  "owner": ["dh3wr", "dl1abc"],
}
\end{lstlisting}

\subsection{Rubrics List}
\label{rubric_list}

\begin{lstlisting}
{
  "_id": "wx-dl-hh"
  "number": 14,
  "description": "Wetter DL-HH",
  "label": "WX DL-HH",
  "transmitter_groups": ["dl-hh","dl-ns"],
  "transmitters": ["db0abc"],
  "cyclic_transmit": true,
  "cyclic_transmit_interval": 60*60, // seconds
  "owner" : ["dh3wr", "dl1abc"]
}
\end{lstlisting}

\subsection{Rubric's content}
<UUID> of rubric (as defined in \ref{rubric_list})

\begin{lstlisting}
{
  "_id" : "<UUID>",
  "rubric": "wx-dl-hh",
  "content": [
    "message1",
    ..,
    "message10"
  ],
}
\end{lstlisting}

\subsection{MQTT services and subscribers}
\label{protocoldef:couchdb:mqttservicesandsubscribers}
\begin{lstlisting}
{
  "_id": "APRS",
  "topic": "aprs"
  "subscribers": [
    {
      "name": "example",
      "password": "<bcrypt hash>"
    },
    ...
  ]
}
\end{lstlisting}
