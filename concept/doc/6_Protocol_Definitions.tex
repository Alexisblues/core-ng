\chapter{Protocol Definitions}

\section{Core REST API}

\subsection{Transmitter sign-on, configuration and heartbeat}
\label{protocoldef:TXsignon}

\texttt{POST /transmitter/bootstrap}
\begin{lstlisting}
{
  "callsign": "db0avr",
  "auth_key": "<secret>",
  "software": {
    "name": "UniPager",
    "version": "1.0.2"
  }
}
\end{lstlisting}

\subsection{Answers to the bootstrap REST call}
\label{protocoldef:TXconfig_or_error}
\texttt{200 OK}
\begin{lstlisting}
{
  "timeslots": [true, true, false, true, ...],
  "nodes": [
    {
      "host": "node1.ampr.org",
      "port": 4000,
      "reachable": true,
      "last_seen": "2018-07-03T07:43:52.783611Z",
      "response_time": 42
    }
  ]
}
\end{lstlisting}

\texttt{423 Locked}
\begin{lstlisting}
{
  "error": "Transmitter temporarily disabled by config."
}
\end{lstlisting}

\texttt{423 Locked}
\begin{lstlisting}
{
  "error": "Transmitter software type not allowed due to serious bug."
}
\end{lstlisting}


\subsection{Transmitter Heartbeat}
\texttt{POST /transmitter/heartbeat}
\begin{lstlisting}
{
  "callsign": "db0avr",
  "auth_key": "<secret>",
  "ntp_synced": true
}
\end{lstlisting}

\subsubsection{Answers to the heartbeat REST call}
\texttt{200 OK}
\begin{lstlisting}
{
  "status": "ok"
}
\end{lstlisting}

If network wants to assign new timeslots without disconnecting (for dynamic timeslots)

\texttt{200 OK}
\begin{lstlisting}
{
  "status": "ok",
  "timeslots": [true, true, false, ...],
  "valid_from": "2018-07-03T08:00:52.786458Z"
}
\end{lstlisting}

If network wants to initiate handover to other node

\texttt{503 Service unavailable}
\begin{lstlisting}
{
  "error": "Node not available, switch to other node."
}
\end{lstlisting}

\section{RabbitMQ}
\label{protocoldef:RabbitMQ}
There are 3 exchanges on each RabbitMQ instance available:
\begin{enumerate}
\item dapnet.calls: Messages coming from other nodes but the node where the instance is running
\item dapnet.local\_calls: Messages coming from the local node instance
\item dapnet.telemetry: Messages containing telemetry from transmitters
\end{enumerate}


\subsection{Transmitters}
\label{protocoldef:RabbitMQ:Transmitters}

Valid Messages are:

\subsubsection{dapnet.calls}
\label{protocoldef:RabbitMQ:dapnet.calls}
The messages to transfer data to be transmitted by the transmitter have the following format.
For each transmission, there is a separate RabbitMQ message, as different receivers might need different text encoding. All encoding is already done, when this message is created. The transmitter does no character encoding at all. Both personal pagings and rubric related messages are transmitted with this protocol.

\begin{lstlisting}
{
	"pagingcall" : {
		"ric" : 12342,
		"subric" : 0 to 3,
		"speed" : 1200,
		"type" : "POCSAG",
		"priority" : 3,
		"message" : "ahdjkahskl"
  }
}
\end{lstlisting}
The selection of the transmitter is done by means of the routing key. Besides, the priority is also used in the RabbitMQ queuing to deliver higher priority messages first.


\subsubsection{dapnet.local\_calls}
\label{protocoldef:RabbitMQ:dapnet.local_calls}
Same as for the the network originated calls in section \ref{protocoldef:RabbitMQ:dapnet.calls}.



\subsection{Telemetry}
On the telemetry exchange, all transmitters publish their telemetry messages. The format the same as in section \ref{protocoldef:telemetry}.

\subsection{MQTT API for third-party consumers}
\label{protocoldef:mqttapi}
In order to allow third-party instances like \href{http://www.aprs-is.net/|APRS}, \href{http://brandmeister.network|Brandmeister} or others to get the emitted calls and rubric contents in a real time event driven way, there is an MQTT API. It is not implemented via a dedicated MQTT broker, but uses the existing RabbitMQ instance (\url{https://www.rabbitmq.com/mqtt.html}. There is no distribution of the messages via this MQTT broker; it is local only. So every node publishes the messages locally on its own.
\todo{check with DL2IC}
Each subscriber has an array of enabled third-party applications. This allow to define the user, if call directed to her/his subscriber shall be also sent to third-party services (see \ref{protocoldef:couchdb:subscribers}.

The currently existing MQTT topics are defined in the CouchDB (see section \ref{protocoldef:couchdb:mqttservicesandsubscribers}). This makes it possible to add more third-party services and authorized users during runtime without the need to update the software.
The valid users to subscribe to the topic are also listed in the same CouchDB database.

The only permitted access for third-party consumers is read. So the subscribe request from a third-party MQTT-Client must use authentication which is checks against the CouchDB data. If correct, read access is granted. Core software has always write access to publish the calls group messages.

The transmitters who are supposed to send out the personal call or the rubric content are published with callsign, geographic location and type of transmitter (widerange or personal). With this generic concept, every third-party application can decide what to do with the content received.

The encoding of the data is UTF-8.

The format of the data published for \textbf{personal paging calls} is
\begin{lstlisting}
{
	"pagingcall" : {
		"srccallsign" : "dl2ic",		
		"dstcallsign" : "dh3wr",
		"dstric" : 12344,
		"dstsubric" : 0 ... 3,
		"priority" : 3,
		"message" : "DAPNET 2.0 rocks dear YL/OM"
		"transmitted_by" : [
			{
				"callsign" : "db0abc",
				"lat" : 12.123456,
				"long" : 32.123456,
				"type" : "PERONAL" | "WIDERANGE"
			},
			{
				"callsign" : "db0def",
				"lat" : 12.123456,
				"long" : 32.123456,
				"type" : "PERONAL" | "WIDERANGE"
			}
		]
	}
}
\end{lstlisting}

The format of the data published for \textbf{rubric\_content paging calls} is
\begin{lstlisting}
{
	"rubricmessage" : {
		
		"message" : ""
		"transmitted_by" : [
			{
				"callsign" : "db0abc",
				"lat" : 12.123456,
				"long" : 32.123456,
				"type" : "PERONAL" | "WIDERANGE"
			},
			{
				"callsign" : "db0def",
				"lat" : 12.123456,
				"long" : 32.123456,
				"type" : "PERONAL" | "WIDERANGE"
			}
		]
	}
}
\end{lstlisting}

\section{Telemetry}
\label{protocoldef:telemetry}
Telemetry is sent from transmitters to the RabbitMQ exchange \textbf{dapnet.telemetry} as defined in section \ref{protocoldef:RabbitMQ}. It is also used in the same way on the websocket API to inform the website and the app about the telemetry in real-time in section \ref{protcoldef:websocketapi:telemetry}.

This is sent every minute in complete. If there are changes, just a subset is sent. The \"name\" key is always mandatory.
\begin{lstlisting}
{
    "name": "db0acb",
    "onair" : true,
    "telemetry" : {
        "ConnectionStatus": {
            "Connected" : true,
            "ConnectedtoNodeName" : "db0xyz"
            "ConnectedtoNodeIP" : "1.2.3.4"
            "ConnectedtoNodePort" : 1234
            "ConnectedSince" : "<timestamp-format>",
	    	"NTPSynced" : true,
            "NTPOffestMilliseconds" : 124
            "NTPServerUsedIP" : ["134.130.4.1", "12.2.3.2"]
        },
		"QueueStatus" : {
        	"QueuedMessages" : {
                "Total" : 1234,
                "Prio1": 1234,
                "Prio2": 1234,
                "Prio3": 1234,
                "Prio4": 1234,
                "Prio5": 1234,
                "Prio10": 1234
	        },
	        "SentMessages": {
                "Total" : 1234,
                "Prio1": 1234,
                "Prio2": 1234,
                "Prio3": 1234,
                "Prio4": 1234,
                "Prio5": 1234,
                "Prio10": 1234
			},
		},
		message_count: 1234,
        "PrefinedTemperatures" : {
            "Unit" : "C" | "F" | "K",
         
            "AirInlet" : 12.2,
            "AirOutlet" : 14.2,
            "Transmitter" : 42.2,
            "PowerAmplifier" : 45.2,
            "CPU" : 93.2,
            "PowerSupply" : 32.4
        },
        "CustomTemperatures" : {
            "Unit" : "C" | "F" | "K",
            [
                {"Value" : 12.2, "Description" : "Aircon Inlet"},
                {"Value" : 16.2, "Description" : "Aircon Outlet"},
                {"Value" : 12.3, "Description" : "Fridge Next to Programmer"}
            ],
        },
        "PowerSupply" : {
            "OnBattery": false,
            "OnEmergencyPower": false,
            "DCInputVoltage" : 12.4,
            "DCInputCurrent" : 3.23
        },
        "RFoutput" : {
            "OutputPowerForwardinWatts": 12.2,
            "OutputPowerReturninWatts" : 12.2,
            "OutputVSWR" : 1.2
        }
	"transmitter_configuration" : {
		"ConfiguredIP": "123.4.3.2",
		"timeslots" : [true, false,...,	false],
		"SoftwareType" : "Unipager" | "MMDVM" | "DAPNET-Proxy",
        "SoftwareVersion" : "v1.2.3", | "20180504" | "v2.3.4",
		"CPUHardwareType" : "Raspberry Pi 3B+"
		"RFHardware" : {
			"C9000" : {
				"UnipagerPowered" : true,
				"ArduinoPADummy" : true,
				"ArduinoPADummySettinginWatts" : 123,
				"ArduinoPADummyPort" : "/devttyUSB0"
or
				"RPC-CardPowered" : false,
				"RPC-Version" : "XOS/2.23pre",
			},
            "Raspager" : {
				"RaspagerMod" : 13,
				"RaspagerPower" : 63,
				"ExternalPowerAmplifier": false,
				"RaspagerRFVersion" : "V2"
			},
			"Audio" : {
				"TXModel" : ["GM1200", "T7F", "GM340", "FREITEXT"],
				"AudioLevelUnipager" : 83,
				"TxDelayinMilliseconds" : 3
			},
			"RFM69" : {
				"Port" : "/dev/ttyUSB0"
			},
			"MMDVM DualHS..." : {
				"DAPNETExclusive" : true
			}
		},
		"DAPNET_Proxy" : {
			"ConnectionStatus" : "connected",
			"ConnectionStatus" : "connecting",
			"ConnectionStatus" : "disconnected"
		}
	}
}
\end{lstlisting}

\section{Statistic, Status and Telemetry REST API}
The statistic and telemetry REST API provides up-to-date information regarding the transmitters and the network via REST. This can be used by e.g. grafana to draw nice graphes or nagios plugins.


\subsection{Statistics}
Statistics are given in JSON with number values only to may parsing easier.

\texttt{GET /stats}
No authentication required. 

Answer:
\texttt{200 OK}
\begin{lstlisting}
{
	"users" : 1234,
	"transmitters_total" : 123,
	"transmitters_online" : {
		"widerange" : 13,
		"personal" : 3
	},
	"nodes_total" : 10,
	"nodes_online" : 19,
	"processed_calls" : 1234,
	"processed_rubric_content_changes" : 234	
}
\end{lstlisting}

\todo{On the calls and rubric content changes: Always increasing counter link traffic on network device or reset at 00:00 am?}


\subsection{Status}
\texttt{GET /status}
No authentication required. 

Answer:
\texttt{200 OK}
\begin{lstlisting}
{
  "nodes": [
    {
      "host": "node1.ampr.org",
      "port": 4000,
      "reachable": true,
      "last_seen": "2018-07-03T07:43:52.783611Z",
      "response_time": 42
    }
  ]
  "rabbitmq_connection_running" : true,
  "couchdb_connection_running" : true,
  "is_hamcloud_node" : false,
  "connection_to_hamcloud_node" : true,
  "general_health" : true
}
\end{lstlisting}


\subsection{Telemetry}

\texttt{GET /telemetry}
No authentication required. Here all stored telemetry from all transmitters is provided.

Answer:
\texttt{200 OK}
See \ref{protocoldef:telemetry}

\texttt{GET /telemetry/<transmittername>}
No authentication required. Here all stored telemetry from the specified transmitter is provided.

Answer:
\texttt{200 OK}
See \ref{protocoldef:telemetry}

\texttt{GET /telemetry/<transmittername>/<section\_of\_telemetry}
No authentication required. Here all stored telemetry within the telemetry section from the specified transmitter is provided.
Possible sections are 2. Level JSON groups, see \ref{protocoldef:telemetry}.
Examples: onair, telemetry, transmitter\_configuration

Answer:
\texttt{200 OK}
See \ref{protocoldef:telemetry}



\section{Websocket API}
\label{protocoldef:websocketapi}
The idea is to provide an API for the website and the app to display real-time information without the need of polling. A websocket server is listing to websocket connections. Authentication is done by a custom JOSN handshake. The connection might be encrypted with SSL if using the Internet or plain if using HAMNET.

\subsection{Telemetry}
\label{protcoldef:websocketapi:telemetry}
URL: \texttt{ws://FQDN/telemetry}.
The data is the same as received from the \textbf{dapnet.telemetry} exchange from the RabbitMQ instance. It is defined in section \ref{protocoldef:telemetry}.

\subsection{Database Changes}
\label{protcoldef:websocketapi:databasechanges}
URL: \texttt{ws://FQDN/database\_changes}.
To inform the website or the app about changes in the CouchDB database, the websocket mirocservice keeps a connection to the local CouchDB API and receives a stream of updated to the database. As there may be data in the changes that are confidential, the stream is parsed and sent out in a reduced form to the websocket client. Further information: \url{http://docs.couchdb.org/en/2.0.0/api/database/changes.html}
\todo{Genaues Format der Ausgaben definieren}

\section{CouchDB Documents and Structure}
\todo{als Tabelle darstellen}



\subsection{Users}

\begin{table}[h]
 \caption{CouchDB: Users}
 \begin{tabular}{r|r|r|r}
  Key & Value-Type & Valid Value Range & Example \\
  \hline
  \_id & STRING & N/A & dl1abc \\
  password & Bcrypt with rand. salt & N/A & ?? \\
  admin & boolean & true/false & true \\
  enabled & boolean & true/false & true \\
  created\_on & DATETIME & & ??\\
  last\_change\_by & STING & valid user name & dh3wr \\
  email\_valid & boolean & true/false & true \\
  avatar\_picture & couchdb\_attachment & & \\
  \end{tabular}
  \label{tab:couchdb:users}
\end{table}

\begin{lstlisting}
{
	"_id": "dl1abc",
	"password": "some hash",
    "email": "user@example.com",
    "admin": true,
    "enabled":true,
    "created_on":<DATETIME>,
    "last_change_by":"dh3wr",
    "email_valid":true
    "avatar_picture": <couchdb attachment??>
}
\end{lstlisting}

\subsection{Nodes}
\begin{table}[h]
 \caption{CouchDB: Nodes}
 \begin{tabular}{r|r|r|r}
  Key & Value-Type & Valid Value Range & Example \\
  \hline
  \_id & STRING & N/A & db0abc \\
  status & ENUM/STRING & OFFLINE | ONLINE | ERROR & ONLINE \\
  version & STRING & ?.?.? & 1.2.3 \\
  ip\_address & IPv4/STRING & & 1.2.3.4 \\
  latitude & decimal number, 6 dec. digits & -90 ... 90 & 34.123456 \\
  longitude & decimal number, 6 dec. digits & -180 ... 180 & 34.123456 \\
  hamcloudnode & boolean & true/false & true \\
  owners & ARRAY of STRING & N/A & ["dl1abc","dh3wr","dl2ic"] \\
  avatar\_picture & couchdb\_attachment & & \\
  \end{tabular}
  \label{tab:couchdb:nodes}
\end{table}

\begin{lstlisting}
{
	"_id" : "db0abc",
	"status" : "OFFLINE" | "ONLINE" | "ERROR",
	"last_update" : DATETIME,
    "version" : "1.2.3",
    "ip_address" : "1.2.3.4",
    "latitude" : 34.123456,
    "longitude" : -23.123456,
    "hamcloudnode" : true,
    "owners" : ["dl1abc","dh3wr","dl2ic"],
    "avatar_picture": <couchdb attachment??>
}
\end{lstlisting}

\subsection{Transmitters}
\todo{Tabelle weiter machen}
\begin{table}[h]
 \caption{CouchDB: Transmitters}
 \begin{tabular}{r|r|r|r}
  Key & Value-Type & Valid Value Range & Example \\
  \hline
  \_id & STRING & N/A & db0abc \\
  auth\_key & STRING & N/A & asd2FD3q3rF \\
  enabled & boolean & true/false & true \\
  status & ENUM/STRING & OFFLINE | ONLINE | UNKNOWN & ONLINE \\
  site\_type & ENUM/STRING & PERSONAL | WIDERANGE & WIDERANGE \\
  aprs\_reporting\_enabled & boolean & true/false & true \\
  last\_update & DATETIME & & ??\\
  last\_connect & DATETIME & & ??\\
  ip\_address & IPv4/STRING & & 1.2.3.4 \\
  device\_type & STRING & Unipager | DAPNET-Proxy & Unipager \\
  device\_version & STRING & ?.?.? & 1.2.3 \\
  latitude & decimal number, 6 dec. digits & -90 ... 90 & 34.123456 \\
  longitude & decimal number, 6 dec. digits & -180 ... 180 & 34.123456 \\
  rf\_power\_watt & decimal number, 3 dec. digits & 0.001 ...  & 12.3 \\ 
    
  
  owners & ARRAY of STRING & N/A & ["dl1abc","dh3wr","dl2ic"] \\
  avatar\_picture & couchdb\_attachment & & \\
  \end{tabular}
  \label{tab:couchdb:transmitters}
\end{table}

\begin{lstlisting}
{
	"_id" : "db0abc",
    "auth_key" : "hdjaskhdlj",
    "enabled" : true,
	"status" : "UNKNOWN" | "OFFLINE" | "ONLINE",
	"site_type" : "PERSONAL" | "WIDERANGE",
	"aprs_reporting_enabled" : true,
    "last_update" : "<DATETIME>",
	"last_connect" : "<DATETIME>",
    "ip_address" : "1.2.3.4",
    "device_type" : "Unipager",
    "device_version" : "1.3.2",
    "latitude" : 23.123456,
    "longitude" : -31.123456
    "rf_power_watt": 12.3,
    "cable_loss_db" : 4.2,
    "antenna_gain_dbi" : 2.34,
	"antenna_agl_m" : 23.4,
	"antenna_type" : "OMNI" | "DIRECTIONAL",
	"antenna_direction" : 123.2,
    "owners" : ["dl1abc","dh3wr","dl2ic"],
    "groups" : ["dl-hh", "dl-all"],
    "frequency_MHz" : 439.9875,
    "emergency_power_available" : false,
    "infinite_emergency_power" : false,
	"emergency_power_duration_hours" : 23.0        
    "antenna_pattern" : <couchDB attachment>,
    "avatar_picture" : <couchDB attachment>
}
\end{lstlisting}

 
\subsection{Subscribers}
\label{protocoldef:couchdb:subscribers}
\todo{check if [] is valid JSON}
\begin{lstlisting}
{
	"_id" : "dl1abc",
	"description" : "Peter",
	"pagers" : [
		{
    		"ric" : {123456, "A"} ... "ric" : {123456, "D"},

			"uuid" : "0023-1233-aefe-1234-3423-9812",
    		"name" : "Peters Alphapoc",

			"type" : "UNKNOWN" | "Skyper" | "AlphaPoc" | "QUIX" | "Swissphone" | "SCALL_XT" | "Birdy"

			"is_enabled" : true
     	},
     	...
     ],
    "enabled_third_party_services" : ["APRS", "BM"],
    "owner" : ["dh3wr", "dl1abc"]
}
\end{lstlisting}

\subsection{Subscriber Groups}

\begin{lstlisting}
{
	"_id" : "ov-G01",
	"description" : "Ortverband Aachen",
	"member_subscribers" : ["dl1abc", "dh3wr"],
    "owner" : ["dh3wr", "dl1abc"],
}
\end{lstlisting}

\subsection{Rubrics List}
\label{rubric_list}

\begin{lstlisting}
{
   	"uuid" : "<UUID>"
    "number" : 14,
    "description" : "Wetter DL-HH",
    "label" : "WX DL-HH",
    "transmitter_groups" : ["dl-hh","dl-ns"],
    "transmitters" : ["db0abc"],
	"cyclic_transmit_enabled" : true,
    "cyclic_transmit_interval_minutes": 123,
 	"owner" : ["dh3wr", "dl1abc"]
}
\end{lstlisting}

\subsection{Rubric's content}
<UUID> of rubric (as defined in \ref{rubric_list})

\begin{lstlisting}
{
	"uuid" : "<UUID>",
	["content_message1",..,"content_message10"],
}
\end{lstlisting}

\subsection{MQTT services and subscribers}
\label{protocoldef:couchdb:mqttservicesandsubscribers}
\begin{lstlisting}
{
	"_id" : "APRS",
	"mqtt_topic_name" : "aprs"
	"allowed_subscribers" : [
		{
			"name" : "example",
			"password" : "<bcrypt hash>"
		},
		...
	]
}
\end{lstlisting}


