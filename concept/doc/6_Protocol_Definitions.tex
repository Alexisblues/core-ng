\chapter{Protocol Definitions}

\section{Microservices API}
\label{protocoldef:microservicesapi}

\subsection{Preamble}
All HTTP(s) communication should be compress with gzip to reduce network load. That's especially important for the answers to GET-calls of all entity's details.

See \hyperref[internalprog:microservices]{Microservices definition}.

\subsection{Database Service}
\subsubsection{GET /users}
\label{protocoldef:microservicesapi:database:getusers}
Returns all users with all details in JSON format.\\

Role \textbf{admin} or \textbf{support} example result:
\begin{lstlisting}
{
  "total_rows": 2,
  "offset": 0,
  "rows": [
    {
      "_id": "dh3wr",
      "_rev": "1-09352254509c9ddf86e80fd83868d557",
      "email": "ralf@secret.com",
      "role": "user",
      "enabled": true,
      "created_on": "2018-07-08T11:50:02.168325Z",
      "created_by": "dl2ic"
    },
    {
      "_id": "dl2ic",
      "_rev": "1-c0a6ecb1a60b58254e808fc68d61ec00",
      "email": "mail@secret.de",
      "role": "admin",
      "enabled": true,
      "created_on": "2018-07-08T11:50:02.168325Z",
      "created_by": "dh3wr"
    }
  ]
}
\end{lstlisting}

Role \textbf{user} example result: \verb|403 Forbidden|



\subsubsection{GET /users?startkey="dh3wr"\&endkey="dl2ic"}
Just for role \textbf{admin} or \textbf{support}. Role \textbf{user} will get\verb|403 Forbidden|.

Return all details of all users in alphabetical order between dh3wr and dl2ic in JSON format.\\
Mapping to CouchDB:\\
\verb|GET /users/_all_docs?startkey="dh3wr"&endkey="dl2ic"&include_docs=true|

Output filtering is the same as \hyperref[protocoldef:microservicesapi:database:getusers]{for single user request} regarding output content and requestor's role


\subsubsection{GET /users/<username>}
\label{protocoldef:microservicesapi:database:getusername}
Return details of <username> in JSON format.\\
Mapping to CouchDB :\\
\verb|GET /users/<username>|

Role \textbf{user} will get \verb|403 Forbidden|, if not asking for her/himself.

Role \textbf{user} example result asking for her/himself or role \textbf{admin} or \textbf{support}:
\begin{lstlisting}
{
  "_id": "dh3wr",
  "_rev": "1-09352254509c9ddf86e80fd83868d557",
  "email": "ralf@secret.com",
  "role": "user",
  "enabled": true,
  "created_on": "2018-07-08T11:50:02.168325Z",
  "created_by": "dl2ic"
}
\end{lstlisting}


\subsubsection{GET /users/\_usernames}
Return just an JSON array of all usernames. Used where selections have to be done on the website.\\
Mapping to CouchDB with filtering in microservice:\\
\verb|GET /users/_all_docs?include_docs=false|

Role \textbf{*} example result:
\begin{lstlisting}
{
  ["dh3wr","dl2ic"]
}
\end{lstlisting}

\subsubsection{PUT /users - Add new user}
Add the user <username>.

Role \textbf{admin} or \textbf{support} or editing the requestor's own entry are the only allowed roles.

User to API: Example content to add user dl6pt
\begin{lstlisting}
{
  "_id" : "dl6pt",
  "password": "$2y$12$lqUueRVo94f439Tt7zqrZOHPfm6YoBzNawWLLIykF3nMip3L6mxLK",
  "email": "ralf@secret.com",
  "role": "admin",
  "enabled": true,
}
\end{lstlisting}

Mapping to CouchDB with adding information by microservice:\\
\verb|PUT /users/<username>|

\begin{lstlisting}
{
  "_id" : "dl6pt",
  "password": "$2y$12$lqUueRVo94f439Tt7zqrZOHPfm6YoBzNawWLLIykF3nMip3L6mxLK",
  "email": "ralf@secret.com",
  "admin": "admin",
  "enabled": true,
  "created_on": "2018-07-08T11:50:02.168325Z",
  "created_by": "dl2ic"
}
\end{lstlisting}
The \verb|created_by| and \verb|created_on| content has to be added by the microservice.


\subsubsection{PUT /users - Edit existing user}
Edit the existing user <username>. Just the changed values have to be sent. The \verb|_id| and \verb|_rev| must be sent always.

Role \textbf{admin} or \textbf{support} or editing the requestor's own entry are the only allowed roles. Other requests result in returning \verb|403 Forbidden|.

User to API: Example content to edit user:\\
First get the user's revision as in \ref{protocoldef:microservicesapi:database:getusername}.

Then generate \verb|PUT| request with content:
\begin{lstlisting}
{
  "_id" : "dl6pt",
  "_rev": "1-09352254509c9ddf86e80fd83868d557",
  "password": "$2y$12$lqUueRVo94f439Tt7zqrZOHPfm6YoBzNawWLLIykF3nMip3L6mxLK",
  "email": "ralf@secret.com",
  "role": "support",
  "enabled": true,
}
\end{lstlisting}

Mapping to CouchDB with adding information by microservice:\\
\verb|PUT /users/<username>|
\begin{lstlisting}
{
  "_id" : "dl6pt",
  "_rev": "1-09352254509c9ddf86e80fd83868d557",
  "password": "$2y$12$lqUueRVo94f439Tt7zqrZOHPfm6YoBzNawWLLIykF3nMip3L6mxLK",
  "email": "ralf@secret.com",
  "role": "support",
  "enabled": true,
  "created_on": "2018-07-08T11:50:02.168325Z",
  "created_by": "dl2ic"
}
\end{lstlisting}

\subsubsection{DELETE /users/<username>?rev=}
Delete user <username>. The Database Service has be make sure that all dependencies of a user account are deleted as well, for example transmitters subscribers or rubrics, that contain \textbf{just} this <username> as owner as the only one entry (left).

Role \textbf{admin} or \textbf{support} or deleting the requestor's own entry are the only allowed roles. Others get as return message \verb|403 Forbidden|.

First get the user's revision as in \ref{protocoldef:microservicesapi:database:getusername}.\\
User to API: \verb|DELETE /users/<username>?rev=1-09352254509c9ddf86e80fd83868d557|

Mapping to CouchDB: direct forward of request


\subsubsection{GET /nodes}
Returns all nodes with all details in JSON format.

\subsubsection{GET /nodes/<nodename>}
Return all details just of <nodename> in JSON format.

\subsubsection{GET /nodes/nodenames}
Return just an JSON array of all nodenames and their description. Used where selections have to be done on the website.

\subsubsection{PUT /nodes/<nodename>}
Add or if existent edit the node <nodename>. If it's existing before, just the changed values have to be sent.

\subsubsection{DELETE /nodes/<nodename>}
Delete node <nodename>. No dependency check necessary.
\todo{Maybe the transmitter service should inform the connected transmitters to the now deleted node to do a switch-over?}

\subsubsection{GET /rubrics}
Returns all rubrics with all setting details in JSON format. This does \textbf{not} include the content of the 10 rubric message slots.

\subsubsection{GET /rubrics/<rubricname>}
Return all setting details just of <rubricname> in JSON format. This does \textbf{not} include the content of the 10 rubric message slots.

\subsubsection{GET /rubrics/rubricnames}
Return just an JSON array of all rubricnames and their description. Used where selections have to be done on the website.

\subsubsection{PUT /rubrics/<rubricname>}
Add or if existent edit the rubric <rubricname>. If it's existing before, just the changed values have to be sent. This is just about the rubrics details, and does \textbf{not} include the content of the 10 rubric message slots.

\subsubsection{DELETE /rubrics/<rubricname>}
Delete rubric <rubricname>. No dependency check necessary. Also delete content of this rubric.

\subsubsection{GET /subscribers}
Returns all subscribers with all details in JSON format.

\subsubsection{GET /subscribers/<subscribername>}
Return all details just of <subscribername> in JSON format.

\subsubsection{GET /subscribers/subscribernames}
Return just an JSON array of all subscribernames and their description. Used where selections have to be done on the website.

\subsubsection{PUT /subscribers/<subscribername>}
Add or if existent edit the subscriber <subscribername>. If it's existing before, just the changed values have to be sent.

\subsubsection{DELETE /subscribers/<subscribername>}
Delete subscriber <subscribername>. If must be also deleted from any subscriber\_group that is containing it. If it is the only one subscriber on a subscriber\_group also delete that subscriber\_group.

\subsubsection{GET /subscriber\_groups}
Returns all subscribers\_goups with all details in JSON format.

\subsubsection{GET /subscriber\_groups/<subscriber\_groupname>}
Return all details just of <subscriber\_groupname> in JSON format.

\subsubsection{GET /subscriber\_groups/subscriber\_groupsnames}
Return just an JSON array of all subscriber\_groupnames and their description. Used where selections have to be done on the website.

\subsubsection{PUT /subscriber\_groups/<subscriber\_groupname>}
Add or if existent edit the subscriber\_group <subscriber\_groupname>. If it's existing before, just the changed values have to be sent.

\subsubsection{DELETE /subscriber\_groups/<subscriber\_groupname>}
Delete subscriber\_group <subscriber\_groupname>. No checks necessary.

\subsubsection{GET /transmitters/\_view/groups}
Returns a JSON array of used transmitter groups tags from all known transmitters. Used for a suggestion of already existing transmitter group tags on the website.

\subsubsection{DELETE /transmitters/<transmittername>}
Delete the transmitter <transmittername>. Also delete the transmitter from explicit entries on rubrics

\subsubsection{PUT /transmitters/<transmittername>}
Add or if existent edit the transmitter <transmittername>. If it's existing before, just the changed values have to be sent.
\todo{Is an active connection reset to that transmitter necessary? If the Authkey changes, an already established connection will keep working? And what about timeslot changes? They have to be applied immediately to the transmitter.}

\subsection{Call Service}

\subsubsection{GET /calls}
Returns the last 100 calls with all details.

\subsubsection{GET /calls?limit=<number>}

Returns the last <number> of calls with all details. If <number> is higher than the available calls, just return all available calls.

\subsubsection{GET /calls/\_view/byDate}
With GET parameters:

\begin{verbatim}
GET /calls/_view/byDate?startkey="<startddate">&endkey="<enddate>"
\end{verbatim}

Returns the calls made within the specified time span with all details. If there are no calls stored in the specified time span, return empty JSON.

\subsubsection{GET /calls/\_view/byIssuer}
\begin{verbatim}
GET /calls/_view/byIssuer?key="dh3wr"
\end{verbatim}

Returns all the calls issued from callsign dh3wr with all details. If there are no calls stored with in the specified time span, return empty JSON. (The microservice has to transfrom the request into \textit{startkey="dh3wr"\&endkey="dh3wr"} to the CouchDB GET request by itself.)

\subsubsection{GET /calls/\_view/byRecipient}
\begin{verbatim}
GET /calls/_view/byRecipient?key="dh3wr"
\end{verbatim}

Returns all the calls with recipient callsign dh3wr with all details. If there are no calls stored in the specified time span, return empty JSON. (The microservice has to transfrom the request into \textit{startkey="dh3wr"\&endkey="dh3wr"} to the CouchDB GET request by itself.)

\todo{Any combination of the given filter method shall be possible. It this possible?}

\subsubsection{GET /calls/\_view/pending}

Return all details of pending calls, that are not transmitted by at least one transmitter.

\subsubsection{GET /calls/\_view/pending\_all}
Return all details of pending calls, that are not transmitted by all designated transmitters.

\subsubsection{POST /call}
Insert call to the system. Send in POST content:
\begin{lstlisting}
{
  "subscriber": ["dh3wr",...],
  "subscriber\_groups": ["ov-g01",...]
  "priority" : 1 to 5,
  "message": "This is an example call",
}
\end{lstlisting}

\subsection{Rubric Service}

\subsubsection{GET /news}
Returns an array of all rubrics and their content in JSON format.

\subsubsection{GET /news/\_view/byRubric}
\begin{verbatim}
GET /news/_view/byRubric?startkey="metar-dl"&endkey="metar-dl"
\end{verbatim}

Returns just the content of <rubricname> content in JSON format.

\subsubsection{GET /news/\_view/byRubric/message\_no>}
Returns just the content of <rubricname> content and message number <message\_no> in JSON format.

\subsubsection{PUT /rubrics/content/<rubricname>}
Add content to rubric <rubricname> on the first message slot and move the existing message one to the end. The 10th. entry will be lost. An automated resend of all rubric content slots will be necessary.

\subsubsection{PUT /rubrics/content/<rubricname>/<message\_no>}
Add or override the content of rubric <rubricname> on the message slot <message\_no>. An automated resend of just this message slot will be necessary.

\subsubsection{DELETE /rubrics/content/<rubricname>}
Delete all content in rubric <rubricname>. The content will be still on Skypers that have received it before, but it will not be transmitted periodically any more. No dependency check necessary.

\subsubsection{DELETE /rubrics/content/<rubricname>/<message\_no>}
Delete the content in rubric <rubricname> with message slot <message\_no>. The content will be still on Skypers that have received it before, but it will not be transmitted periodically any more. No dependency check necessary.

\subsection{Transmitter Service}

\subsubsection{GET /transmitters}
Return all transmitters with all details in JSON format.

\subsubsection{GET /transmitter/<transmittername>}
Return all details just of transmitter <transmittername>.

\subsubsection{GET /transmitters/transmitternames}
Return an JSON array of all transmitter names. Used where selections have to be done on the website.

\subsubsection{POST /transmitters/bootstrap}
\label{protcoldef:transmitters:bootstrap}
\texttt{POST /transmitter/bootstrap}
\begin{lstlisting}
{
  "callsign": "db0avr",
  "auth_key": "<secret>",
  "software": {
    "name": "UniPager",
    "version": "1.0.2"
  }
}
\end{lstlisting}

\textbf{Answers to the bootstrap REST call}

\texttt{200 OK}
\begin{lstlisting}
{
  "timeslots": [true, true, false, true, ...],
  "nodes": [
    {
      "host": "node1.ampr.org",
      "port": 4000,
      "reachable": true,
      "last_seen": "2018-07-03T07:43:52.783611Z",
      "response_time": 42
    }
  ]
}
\end{lstlisting}

\texttt{423 Locked}
\begin{lstlisting}
{
  "error": "Transmitter temporarily disabled by config."
}
\end{lstlisting}

\texttt{423 Locked}
\begin{lstlisting}
{
  "error": "Transmitter software type not allowed due to serious bug."
}
\end{lstlisting}


\subsubsection{POST /transmitters/heartbeat}
\texttt{POST /transmitter/heartbeat}
\begin{lstlisting}
{
  "callsign": "db0avr",
  "auth_key": "<secret>",
  "ntp_synced": true
}
\end{lstlisting}

\textbf{Answers to the heartbeat REST call}
\texttt{200 OK}
\begin{lstlisting}
{
  "status": "ok"
}
\end{lstlisting}

If network wants to assign new timeslots without disconnecting (for dynamic timeslots)

\texttt{200 OK}
\begin{lstlisting}
{
  "status": "ok",
  "timeslots": [true, true, false, ...],
  "valid_from": "2018-07-03T08:00:52.786458Z"
}
\end{lstlisting}

If network wants to initiate handover to other node

\texttt{503 Service unavailable}
\begin{lstlisting}
{
  "error": "Node not available, switch to other node."
}
\end{lstlisting}


\subsection{Cluster Service}

\subsubsection{POST /cluster/discovery}


\subsection{Telemetry Service}

\subsubsection{GET /telemetry/transmitters}
Return the stored telemetry \textbf{summary} values for all transmitters.

\subsubsection{GET /telemetry/transmitters/<transmittername>}
Return all the stored telemetry values for transmitter <transmittername>.

\subsubsection{GET /telemetry/nodes}
Return the stored telemetry \textbf{summary} values for all nodes.

\subsubsection{GET /telemetry/nodes/<nodesname>}
Return all the stored telemetry values for node <nodename>.

\subsubsection{WS /telemetry}
See \hyperref[protocoldef:websocketapi]{the section for Websocket API}.


\subsection{Database Changes Service}

\subsubsection{WS /changes}
See \hyperref[protcoldef:websocketapi:databasechanges]{the section for Websocket API on database changes}.

\subsection{Status Service}
The purpose of the status service is to provide a short overview of the DAPNET network and the microservices.

\subsubsection{GET /status/nodes}
No authentication required.

Answer:
\texttt{200 OK}
\begin{lstlisting}
{
  "nodes": [
    {
      "host": "node1.ampr.org",
      "port": 4000,
      "reachable": true,
      "last_seen": "2018-07-03T07:43:52.783611Z",
      "response_time": 42
    }
  ],
  "connections": {
    "rabbitmq": true,
    "couchdb": true,
    "hamcloud": true,
  },
  "hamcloud_node": false,
  "general_health": true
}
\end{lstlisting}
\todo{What is "port"?}

\subsubsection{GET /status/node/<nodename>}
No authentication required.

Answer:
\texttt{200 OK}
\begin{lstlisting}
{
  "host": "node1.ampr.org",
  "port": 4000,
  "reachable": true,
  "last_seen": "2018-07-03T07:43:52.783611Z",
  "response_time": 42,
  "connections": {
    "rabbitmq": true,
    "couchdb": true,
    "hamcloud": true,
  },
  "hamcloud_node": false,
  "general_health": true
}
\end{lstlisting}
\todo{What is "port"?}


\subsubsection{GET /status}
Get status of this node.
\texttt{200 OK}
\begin{lstlisting}
{
  "good_health" : true,
  "version" : "1.2.3"
  "microservices\_running" : {
    "database" : true,
    "call" : true,
    "rubric" : true,
    "transmitter" : true,
    "cluster" : true,
    "telemetry" : true,
    "database-changes" : true,
    "statistics" : true,
    "rabbitmq" : true,
    "thirdparty" : true
  }
}
\end{lstlisting}

\subsubsection{GET /status/<service\_name>}
List of valid values for \textit{service\_name}:

database-service\\
call-service\\
rubric-service\\
transmitter-service\\
cluster-service\\
telemetry-service\\
database-changes-service\\
statistics-service\\
rabbitmq-service\\


\texttt{200 OK}
\begin{lstlisting}
<Status output from service itself>
\end{lstlisting}


\subsection{Statistics Service}

\subsubsection{GET /statistics}
No authentication required.

Answer:
\texttt{200 OK}
\begin{lstlisting}
{
  "users" : 1234,
  "transmitters": {
    "personal": {
      "online": 13
      "total": 34
    },
    "widerage": {
      "online": 53,
      "total": 97
    }
  }
  "nodes": {
    "online": 10,
    "total": 19
  },
  "processed_calls": 1234,
  "processed_rubric_content_changes": 234
}
\end{lstlisting}

\todo{On the calls and rubric content changes: Always increasing counter link traffic on network device or reset at 00:00 am?}

\subsection{RabbitMQ Service}

\subsubsection{GET /rabbitmq/*}


\section{RabbitMQ}
\label{protocoldef:RabbitMQ}
There are 3 exchanges available on each RabbitMQ instance:
\begin{description}
\item[dapnet.calls] Messages shared between all nodes
\item[dapnet.local\_calls] Messages coming from the local node instance
\item[dapnet.telemetry] Messages containing telemetry from transmitters
\end{description}


\subsection{Transmitters}
\label{protocoldef:RabbitMQ:Transmitters}

Valid Messages are:

\subsubsection{dapnet.calls}
\label{protocoldef:RabbitMQ:dapnet.calls}
The messages to transfer data to be transmitted by the transmitter have the
following format.

For each transmission, there is a separate RabbitMQ message, as different
receivers might need different text encoding. All encoding is already done, when
this message is created. The transmitter does no character encoding at all. Both
personal pagings and rubric related messages are transmitted with this protocol.

\begin{lstlisting}
{
  "id": "016c25fd-70e0-56fe-9d1a-56e80fa20b82",
  "protocol": "pocsag",
  "priority": 3,
  "expires": "2018-07-03T08:00:52.786458Z",
  "message": {
    "ric": 12342, (max 21 Bits)
    "type": "alphanum", | "numeric"
    "speed": 1200,
    "function": 0 to 3,
    "data": "Lorem ipsum dolor sit amet"
  }
}
\end{lstlisting}
The selection of the transmitter is done by means of the routing key. Besides,
the priority is also used in the RabbitMQ queuing to deliver higher priority
messages first.

\subsubsection{dapnet.local\_calls}
\label{protocoldef:RabbitMQ:dapnet.local_calls}
Same as for the the network originated calls in section \ref{protocoldef:RabbitMQ:dapnet.calls}.

\subsection{Telemetry}
On the telemetry exchange, all transmitters and nodes publish their telemetry messages. The format the same as in section \ref{protocoldef:telemetrytx} and \ref{protocoldef:telemetrynodes}.

\subsection{MQTT API for third-party consumers}
\label{protocoldef:mqttapi}
In order to allow third-party instances like \href{http://www.aprs-is.net/|APRS}, \href{http://brandmeister.network|Brandmeister} or others to get the emitted calls and rubric contents in a real time event driven way, there is an MQTT API. It is not implemented via a dedicated MQTT broker, but uses the existing RabbitMQ instance (\url{https://www.rabbitmq.com/mqtt.html}. There is no distribution of the messages via this MQTT broker; it is local only. So every node publishes the messages locally on its own.
\todo{check with DL2IC}
Each subscriber has an array of enabled third-party applications. This allow to define the user, if call directed to her/his subscriber shall be also sent to third-party services (see \ref{protocoldef:couchdb:subscribers}.

The currently existing MQTT topics are defined in the CouchDB (see section \ref{protocoldef:couchdb:mqttservicesandsubscribers}). This makes it possible to add more third-party services and authorized users during runtime without the need to update the software.
The valid users to subscribe to the topic are also listed in the same CouchDB database.

The only permitted access for third-party consumers is read. So the subscribe request from a third-party MQTT-Client must use authentication which is checks against the CouchDB data. If correct, read access is granted. Core software has always write access to publish the calls group messages.

The transmitters who are supposed to send out the personal call or the rubric content are published with callsign, geographic location and type of transmitter (widerange or personal). With this generic concept, every third-party application can decide what to do with the content received.

The encoding of the data is UTF-8.

The format of the data published for \textbf{personal paging calls} is
\begin{lstlisting}
{
  "pagingcall" : {
    "srccallsign" : "dl2ic",
    "dstcallsign" : "dh3wr",
    "dstric" : 12354,
    "dstfunction" : 0 .. 3,
    "priority" : 3,
    "message" : "DAPNET 2.0 rocks dear YL/OM"
    "transmitted_by" : [
      {
        "callsign" : "db0abc",
        "lat" : 12.123456,
        "long" : 32.123456,
        "type" : "personal" | "widerange"
      },
      {
        "callsign" : "db0def",
        "lat" : 12.123456,
        "long" : 32.123456,
        "type" : "personal" | "widerange"
      }
    ],
    "timestamp" : "2018-07-03T08:00:52.786458Z"
  }
}
\end{lstlisting}

The format of the data published for \textbf{rubric\_content paging calls} is
\begin{lstlisting}
{
  "rubricmessage" : {
    "message" : ""
    "transmitted_by" : [
      {
        "callsign" : "db0abc",
        "lat" : 12.123456,
        "long" : 32.123456,
        "type" : "PERONAL" | "WIDERANGE"
      },
      {
        "callsign" : "db0def",
        "lat" : 12.123456,
        "long" : 32.123456,
        "type" : "PERONAL" | "WIDERANGE"
      }
    ],
    "timestamp" : "2018-07-03T08:00:52.786458Z"
  }
}
\end{lstlisting}

\section{Telemetry from Transmitters}
\label{protocoldef:telemetrytx}
Telemetry is sent from transmitters to the RabbitMQ exchange
\textbf{dapnet.telemetry} as defined in section \ref{protocoldef:RabbitMQ}. It
is also used in the same way on the websocket API to inform the website and the
app about the telemetry in real-time in section
\ref{protcoldef:websocketapi:telemetrytxsummary} and \ref{protcoldef:websocketapi:telemetrytxdetail}.

This is sent every minute in complete. If there are changes, just a subset is sent.
The name of the transmitter is used as routing key for the message.

\begin{lstlisting}
{
  "onair": true,
  "node": {
    "name": "db0xyz",
    "ip": "44.42.23.8",
    "port": 1234,
    "connected": true,
    "connected_since": "2018-07-03T08:00:52.786458Z"
   },
  "ntp": {
    "synced": true,
    "offset": 124,
    "server": ["134.130.4.1", "12.2.3.2"],
  },
  "messages": {
    "queued": [123, 123, 123, 123, 123, 123],
    "sent": [123, 123, 123 , 123, 123, 123]
  },
  "temperatures": {
    "unit": "C" | "F" | "K",
    "air_inlet": 12.2,
    "air_outlet": 14.2,
    "transmitter": 42.2,
    "power_amplifier": 45.2,
    "cpu": 93.2,
    "power_supply": 32.4,
    "custom": [
      {"value": 12.2, "description": "Aircon Inlet"},
      {"value": 16.2, "description": "Aircon Outlet"},
      {"value": 12.3, "description": "Fridge Next to Programmer"}
    ]
  },
  "power_supply": {
    "on_battery": false,
    "on_emergency_power": false,
    "dc_input_voltage": 12.4,
    "dc_input_current": 3.23
  },
  "rf_output" : {
    "fwd": 12.2,
    "refl" : 12.2,
    "vswr" : 1.2
  },
  "config": {
    "ip": "123.4.3.2",
    "timeslots" : [true, false,...,	false],
    "software": {
      name: "Unipager" | "MMDVM" | "DAPNET-Proxy",
      version: "v1.2.3", | "20180504" | "v2.3.4",
    },
  }
  "hardware": {
    "platform": "Raspberry Pi 3B+"
  },
  "rf_hardware": {
    "c9000": {
      "name" : "C9000 Compact",
      "<pa_dummy>" : {
        "output_power" : 123,
        "port" : "/dev/ttyUSB0"
      }
      "<rpc>": {
        "version" : "XOS/2.23pre"
      }
    },
    "raspager": {
      "name": Raspager",
      "modulation": 13,
      "power": 63,
      "external_pa": false,
      "version": "V2"
    },
    "audio": {
      "name" = "Audio",
      "transmitter": "GM1200" | "T7F" | "GM340" | "FREITEXT",
      "audio_level": 83,
      "tx_delay": 3
    },
    "rfm69": {
      "name" : "RFM69",
      "port": "/dev/ttyUSB0"
    },
    "mmdvm": {
      "name" : "MMDVM",
      "dapnet_exclusive": true
    }
  },
  "proxy" : {
    "status": "connected" | "connecting" | "disconnected"
  }
}
\end{lstlisting}

\section{Telemetry from Nodes}
\label{protocoldef:telemetrynodes}
Telemetry is sent from nodes to the RabbitMQ exchange
\textbf{dapnet.telemetry} as defined in section \ref{protocoldef:RabbitMQ}. It
is also used in the same way on the websocket API to inform the website and the
app about the telemetry in real-time in section
\ref{protcoldef:websocketapi:telemetrynodessummary} and \ref{protcoldef:websocketapi:telemetrynodesdetail}.

This is sent every minute in complete. If there are changes, just a subset is sent.
The name of the nodes is used as routing key for the message.
\begin{lstlisting}
{
  "good_health" : true,
  "microservices" : {
    "database" : {
      "ok" : true,
      "version" : "1.2.3"
    },
    "call" : {
      "ok" : true,
      "version" : "1.2.3"
    },
    "rubric" :  {
      "ok" : true,
      "version" : "1.2.3"
    },
    "transmitter" :  {
      "ok" : true,
      "version" : "1.2.3"
    },
    "cluster" :  {
      "ok" : true,
      "version" : "1.2.3"
    },
    "telemetry" : {
      "ok" : true,
      "version" : "1.2.3"
    },
    "database-changes" :  {
      "ok" : true,
      "version" : "1.2.3"
    },
    "statistics" :  {
      "ok" : true,
      "version" : "1.2.3"
    },
    "rabbitmq" :  {
      "ok" : true,
      "version" : "1.2.3"
    },
    "thirdparty" :  {
      "ok" : true,
      "version" : "1.2.3"
    },
  },
  "connections" : {
    "transmitters" : 123,
    "third_party" : 3
  },
  "system" : {
    "free_disk_space_mb": 1234
    "cpu_utilization": 0.2
    "is_hamcloud" : false
  }
}
\end{lstlisting}

\section{Statistic, Status and Telemetry REST API}
The statistic and telemetry REST API provides up-to-date information regarding the transmitters and the network via REST. This can be used by e.g. grafana to draw nice graphes or nagios plugins.





\subsection{Telemetry from Transmitters}

\texttt{GET /telemetry/transmitters}

No authentication required. Here all stored telemetry from all transmitters is provided.

Answer:
\texttt{200 OK}
See \ref{protocoldef:telemetrytx}\\\\

\texttt{GET /telemetry/transmitters/<transmittername>}

No authentication required. Here all stored telemetry from the specified transmitter is provided.

Answer:
\texttt{200 OK}

See \ref{protocoldef:telemetrytx}\\\\

\texttt{GET /telemetry/transmitters/<transmittername>/<section\_of\_telemetry>}

No authentication required. Here all stored telemetry within the telemetry
section from the specified transmitter is provided. Possible sections are 2.
Level JSON groups, see \ref{protocoldef:telemetrytx}.

Examples: onair, telemetry, transmitter\_configuration

Answer:
\texttt{200 OK}

See \ref{protocoldef:telemetrytx}

\subsection{Telemetry from Nodes}

\texttt{GET /telemetry/nodes}

No authentication required. Here all stored telemetry from all nodes is provided.

Answer:
\texttt{200 OK}
See \ref{protocoldef:telemetrynodes}\\\\

\texttt{GET /telemetry/nodes/<nodename>}

No authentication required. Here all stored telemetry from the specified node is provided.

Answer:
\texttt{200 OK}

See \ref{protocoldef:telemetrynodes}\\\\


\section{Websocket API}
\label{protocoldef:websocketapi}
The idea is to provide an API for the website and the app to display real-time
information without the need of polling. A websocket server is listing to
websocket connections. Authentication is done by a custom JOSN handshake. The
connection might be encrypted with SSL if using the Internet or plain if using
HAMNET.

The data is taken from the \textbf{dapnet.telemetry} exchange
from the RabbitMQ instance and further other sources if necessary.

\todo{Define if authentication is necessary of some endpoints?}

There are 5 main endpoints in the websocket interface:


\begin{center}
  \begin{tabular}{|l|l|} \hline
    Endpoint & Microservice \\ \hline \hline
    \verb|WS     /telemetry/transmitters| & Summary data of all TX \\ \hline
    \verb|WS     /telemetry/transmitters/<TxName>| & Details for TX <TxName>\\ \hline
    \verb|WS     /telemetry/nodes| & Summary data of all Nodes\\ \hline
    \verb|WS     /telemetry/nodes/<NodeName>| & Details for Node <NodeName>\\ \hline
    \verb|WS     /changes| & Database changes\\ \hline

  \end{tabular}
\end{center}


\subsection{Telemetry from Transmitters - Summary of all TX}
\label{protcoldef:websocketapi:telemetrytxsummary}
URL: \texttt{ws://FQDN/telemetry/transmitters}\\\\

The data is the same as received from the \textbf{dapnet.telemetry} exchange
from the RabbitMQ instance. It is defined in section
\ref{protocoldef:telemetrytx}.\\
The websocket-Server generates an array of JSON Objects which have the name of the transmitter obtained from the RabbitMQ routing key.\\
The current time slot is also sent in the summary and updated also by its own every time a time slot change happens.

\begin{lstlisting}
{
  "transmitters": [
    "db0abc" : {
      "onair": true,
      "node": {
        "name": "db0xyz",
        "ip": "44.42.23.8",
        "port": 1234,
        "connected": true,
        "connected_since": "2018-07-03T08:00:52.786458Z"
       },
      "ntp": {
        "synced": true
      },
      "messages": {
        "queued": [123, 123, 123, 123, 123, 123],
        "sent": [123, 123, 123 , 123, 123, 123]
      },
      "config": {
        "ip": "123.4.3.2",
        "timeslots" : [true, false,...,	false],
      "software": {
        name: "Unipager" | "MMDVM" | "DAPNET-Proxy",
        version: "v1.2.3", | "20180504" | "v2.3.4"
      },
      "proxy" : {
        "status": "connected" | "connecting" | "disconnected"
      }
    },
    "db0xyz" : {
      "onair": true,
      "node": {
    ....
    }        
  ],
  "current_timeslot" : 12
}
\end{lstlisting}

\subsection{Telemetry from Transmitters - Details of Transmitter}
\label{protcoldef:websocketapi:telemetrytxdetail}
URL: \texttt{ws://FQDN/telemetry/transmitters/<transmittername>}\\\\

The data is the same as received from the \textbf{dapnet.telemetry} exchange
from the RabbitMQ instance. It is defined in section
\ref{protocoldef:telemetrytx}.\\
The websocket-Server gives out all the telemetry data from a certain transmitter. The name of the transmitter obtained from the RabbitMQ routing key. 

\begin{lstlisting}
{
  "onair": true,
  "node": {
  "ip": "44.42.23.8",
    "port": 1234,
    "connected": true,
    "connected_since": "2018-07-03T08:00:52.786458Z"
  },
  "ntp": {
    "synced": true,
    "offset": 124,
    "server": ["134.130.4.1", "12.2.3.2"],
  },
  "messages": {
    "queued": [123, 123, 123, 123, 123, 123],
    "sent": [123, 123, 123 , 123, 123, 123]
  },
  "temperatures": {
    "unit": "C" | "F" | "K",
    "air_inlet": 12.2,
    "air_outlet": 14.2,
    "transmitter": 42.2,
    "power_amplifier": 45.2,
    "cpu": 93.2,
    "power_supply": 32.4,
    "custom": [
      {"value": 12.2, "description": "Aircon Inlet"},
      {"value": 16.2, "description": "Aircon Outlet"},
      {"value": 12.3, "description": "Fridge Next to Programmer"}
    ]
  },
  "power_supply": {
    "on_battery": false,
    "on_emergency_power": false,
    "dc_input_voltage": 12.4,
    "dc_input_current": 3.23
  },
  "rf_output" : {
    "fwd": 12.2,
    "refl" : 12.2,
    "vswr" : 1.2
  },
  "config": {
    "ip": "123.4.3.2",
    "timeslots" : [true, false,...,	false],
    "software": {
      name: "Unipager" | "MMDVM" | "DAPNET-Proxy",
      version: "v1.2.3", | "20180504" | "v2.3.4",
    },
  }
  "hardware": {
    "platform": "Raspberry Pi 3B+"
  },
  "rf_hardware": {
    "c9000": {
      "name" : "C9000 Compact",
      "<pa_dummy>" : {
        "output_power" : 123,
        "port" : "/dev/ttyUSB0"
      }
      "<rpc>": {
        "version" : "XOS/2.23pre"
      }
    },
    "raspager": {
      "name": Raspager",
      "modulation": 13,
      "power": 63,
      "external_pa": false,
      "version": "V2"
    },
    "audio": {
      "name" = "Audio",
      "transmitter": "GM1200" | "T7F" | "GM340" | "FREITEXT",
      "audio_level": 83,
      "tx_delay": 3
    },
    "rfm69": {
      "name" : "RFM69",
      "port": "/dev/ttyUSB0"
    },
    "mmdvm": {
      "name" : "MMDVM",
      "dapnet_exclusive": true
    }
  },
  "proxy" : {
    "status": "connected" | "connecting" | "disconnected"
  }
}
\end{lstlisting}

\subsection{Telemetry from Nodes - Summary of all Nodes}
\label{protcoldef:websocketapi:telemetrynodessummary}
URL: \texttt{ws://FQDN/telemetry/nodes}\\\\

The websocket-Server generates an array of JSON Objects which have the name of the node obtained from the RabbitMQ routing key.

\begin{lstlisting}
{
  "nodes" : [
    "db0sda" : {
      "good_health" : true,
      "connections" : {
        "transmitters" : 123,
        "third_party" : 3
      },
      "system" : {
        "is_hamcloud" : false
      }
    },
    "hamcloud1" : {
      "good_health" : true,
      "connections" : {
        "transmitters" : 658,
        "third_party" : 25
      },
      "system" : {
        "is_hamcloud" : true
      }
    },
    ....
  ]
}
\end{lstlisting}

\subsection{Telemetry from Transmitters - Details of Node}
\label{protcoldef:websocketapi:telemetrynodesdetail}
URL: \texttt{ws://FQDN/telemetry/nodes/<nodename>}\\\\

The data is the same as received from the \textbf{dapnet.telemetry} exchange
from the RabbitMQ instance. It is defined in section
\ref{protocoldef:telemetrytx}.\\
The websocket-Server gives out all the telemetry data from a certain node. The name of the transmitter obtained from the RabbitMQ routing key. 

\begin{lstlisting}
{
  "good_health" : true,
  "microservices" : {
    "database" : {
      "ok" : true,
      "version" : "1.2.3"
    },
    "call" : {
      "ok" : true,
      "version" : "1.2.3"
    },
    "rubric" :  {
      "ok" : true,
      "version" : "1.2.3"
    },
    "transmitter" :  {
      "ok" : true,
      "version" : "1.2.3"
    },
    "cluster" :  {
      "ok" : true,
      "version" : "1.2.3"
    },
    "telemetry" : {
      "ok" : true,
      "version" : "1.2.3"
    },
    "database-changes" :  {
      "ok" : true,
      "version" : "1.2.3"
    },
    "statistics" :  {
      "ok" : true,
      "version" : "1.2.3"
    },
    "rabbitmq" :  {
      "ok" : true,
      "version" : "1.2.3"
    },
    "thirdparty" :  {
      "ok" : true,
      "version" : "1.2.3"
    },
  },
  "connections" : {
    "transmitters" : 123,
    "third_party" : 3
  },
  "system" : {
    "free_disk_space_mb": 1234
    "cpu_utilization": 0.2
    "is_hamcloud" : false
  }
}
\end{lstlisting}

\subsection{Database Changes}
\label{protcoldef:websocketapi:databasechanges}
URL: \texttt{ws://FQDN/changes}\\

To inform the website or the app about changes in the CouchDB database, the
websocket microservice keeps a connection to the local CouchDB API and receives
a stream of updated to the database. As there may be data in the changes that
are confidential, the stream is parsed and sent out in a reduced form to the
websocket client. Further information:
\url{http://docs.couchdb.org/en/2.0.0/api/database/changes.html}

The format of the updates is:

\todo{define/review format}

\subsubsection{Transmitter related}
\texttt{New transmitter added}

\begin{lstlisting}
{
  "type": "transmitter",
  "action" : "added",
  "name": "db0abc",
  "data" : {
  (Data from CouchDB Change feed in processed way)
  }
}
\end{lstlisting}

\texttt{Existing transmitter changed}
\begin{lstlisting}
{
  "type": "transmitter",
  "action" : "changed",
  "name": "db0abc",
  "data" : {
  (Data from CouchDB Change feed in processed way)
  }
}
\end{lstlisting}

\texttt{Transmitter deleted}
\begin{lstlisting}
{
  "type": "transmitter",
  "action" : "deleted",
  "name": "db0abc"
\end{lstlisting}

\subsubsection{User related}
\texttt{New User added}
\begin{lstlisting}
{
  "type": "user",
  "action" : "added",
  "name": "db1abc",
  "data" : {
  (Data from CouchDB Change feed in processed way)
  }
}
\end{lstlisting}

\texttt{Existing user changed}
\begin{lstlisting}
{
  "type": "user",
  "action" : "changed",
  "name": "db1abc",
  "data" : {
  (Data from CouchDB Change feed in processed way)
  }
}
\end{lstlisting}

\texttt{User deleted}
\begin{lstlisting}
{
  "type": "user",
  "action" : "deleted",
  "name": "db1abc"
}
\end{lstlisting}


\subsubsection{Rubric related}
\texttt{New Rubric added}
\begin{lstlisting}
{
  "type": "rubric",
  "action" : "added",
  "id": "...",
  "data" : {
  (Data from CouchDB Change feed in processed way)
  }
}
\end{lstlisting}

\texttt{Existing rubric changed}
\begin{lstlisting}
{
  "type": "user",
  "action" : "changed",
  "id": "...",
  "data" : {
  (Data from CouchDB Change feed in processed way)
  }
}
\end{lstlisting}

\texttt{Rubric deleted}
\begin{lstlisting}
{
  "type": "user",
  "action" : "deleted",
  "id": "..."
}
\end{lstlisting}

\subsubsection{Rubric content related}
\todo{Check against CouchDB structure}

\texttt{New Rubric content added}
\begin{lstlisting}
{
  "type": "rubric_content",
  "action" : "added",
  "id": "...??",
  "data" : {
  (Complete Data dump of all ten rubric messages as stored in CouchDB)
  }
}
\end{lstlisting}

\texttt{Existing rubric changed}
\begin{lstlisting}
{
  "type": "rubric_content",
  "action" : "changed",
  "id": "...",
  "data" : {
  (Complete Data dump of all ten rubric messages as stored in CouchDB)
  }
}
\end{lstlisting}

\texttt{Rubric content deleted}
\begin{lstlisting}
{
  "type": "rubric_content",
  "action" : "deleted",
  "id": "..."
  "data" : {
  (Complete Data dump of all ten rubric messages as stored in CouchDB, some may be empty)
  }
}
\end{lstlisting}


\subsubsection{Node related}
\texttt{New node added}
\begin{lstlisting}
{
  "type": "node",
  "action" : "added",
  "name": "db0abc",
  "data" : {
  (Data from CouchDB Change feed in processed way)
  }
}
\end{lstlisting}

\texttt{Existing node changed}
\begin{lstlisting}
{
  "type": "node",
  "action" : "changed",
  "name": "db0abc",
  "data" : {
  (Data from CouchDB Change feed in processed way)
  }
}
\end{lstlisting}

\texttt{Node deleted}
\begin{lstlisting}
{
  "type": "node",
  "action" : "deleted",
  "name": "db1abc"
}
\end{lstlisting}


\section{CouchDB Documents and Structure}
\todo{als Tabelle darstellen}

\subsection{Users}

\begin{table}[h]
 \centering
 \caption{CouchDB: Users}
 \begin{tabular}{|l|l|l|l|} \hline
  Key & Value-Type & Valid Value Range & Example \\
  \hline
  \_id & string & & dl1abc \\
  password & string & bcrypt hash & --- \\
  email & string & & dl1abc@darc.de \\
  role & string & "admin"|"support"|"user" & true \\
  enabled & boolean & & true \\
  created\_on & string & ISO8601 & 2018-07-08T11:50:02.168325Z \\
  changed\_on & string & ISO8601 & 2018-07-08T11:50:02.168325Z \\
  changed\_by & string & valid user name & dh3wr \\
  email\_valid & boolean & & true \\
  avatar\_picture & couchdb\_attachment & & \\ \hline
  \end{tabular}
  \label{tab:couchdb:users}
\end{table}

\begin{lstlisting}
{
  "_id": "dl1abc",
  "password": "<bcrypt hash>",
  "email": "dl1abc@darc.de",
  "role": "admin",
  "enabled": true,
  "created_on": "2018-07-03T08:00:52.786458Z",
  "created_by": "dh3wr",
  "changed_on": "2018-07-03T08:00:52.786458Z",
  "changed_by":"dh3wr",
  "email_valid": true
  "avatar_picture": <couchdb attachment>
}
\end{lstlisting}

\todo{Wofür genau braucht man email\_valid? - Um ab und zu mal eine Testmail an die User zu schicken, ob sie unter der Email noch erreichbar sind und sonst sie zu löschen.}

\subsection{Nodes}
\begin{table}[h]
 \caption{CouchDB: Nodes}
 \begin{tabular}{|l|l|l|l|} \hline
  Key & Value-Type & Valid Value Range & Example \\
  \hline
  \_id & STRING & N/A & db0abc \\
  coordinates & [number; 2]  & [lat, lon] & [34.123456, 6.23144] \\
  description & string & whatever & Aachen, Germany\\
  hamcloud & boolean & true/false & true \\
  created\_on & string & ISO8601 & 2018-07-08T11:50:02.168325Z \\
  changed\_by & string & valid user name & dh3wr \\
  changed\_on & string & ISO8601 & 2018-07-08T11:50:02.168325Z \\
  changed\_by & string & valid user name & dh3wr \\
  owners & [string] & N/A & ["dl1abc","dh3wr","dl2ic"] \\
  avatar\_picture & couchdb\_attachment & & \\ \hline
  \end{tabular}
  \label{tab:couchdb:nodes}
\end{table}

\begin{lstlisting}
{
  "_id": "db0abc",
  "auth_key": "super_secret_key",
  "coordinates": [34.123456, -23.123456],
  "description": "some words about that node",
  "hamcloud": true,
  "created_on": "2018-07-03T08:00:52.786458Z",
  "created_by":"dh3wr",
  "changed_on": "2018-07-03T08:00:52.786458Z",
  "changed_by":"dh3wr",
  "owners": ["dl1abc","dh3wr","dl2ic"],
  "avatar_picture": <couchdb attachment??>
}
\end{lstlisting}

\subsection{Transmitters}
\todo{Tabelle weiter machen}
\begin{table}[h]
 \caption{CouchDB: Transmitters}
 \begin{tabular}{|l|l|l|l|}\hline
  Key & Value-Type & Valid Value Range & Example \\
  \hline
  \_id & string & N/A & db0abc \\
  auth\_key & string & N/A & asd2FD3q3rF \\
  enabled & boolean & true/false & true \\
  usage & string & PERSONAL | WIDERANGE & WIDERANGE \\
  coordinates & [number; 2]  & [lat, lon] & [34.123456, 6.23144] \\
  power & number & 0.001 ...  & 12.3 \\
  created\_on & string & ISO8601 & 2018-07-08T11:50:02.168325Z \\
  changed\_by & string & valid user name & dh3wr \\
  changed\_on & string & ISO8601 & 2018-07-08T11:50:02.168325Z \\
  changed\_by & string & valid user name & dh3wr \\
  owners & ARRAY of STRING & N/A & ["dl1abc","dh3wr","dl2ic"] \\
  avatar\_picture & couchdb\_attachment & & \\ \hline
  \end{tabular}
  \label{tab:couchdb:transmitters}
\end{table}

\begin{lstlisting}
{
  "_id": "db0abc",
  "auth_key": "hdjaskhdlj",
  "enabled": true,
  "usage": "personal" | "widerange",
  "coordinates": [34.123456, -23.123456],
  "power": 12.3,
  "antenna": {
    "agl": 23.4,
    "gain": 2.34,
    "type": "omni" | "directional",
    "direction": 123.2,
    "cable_loss": 4.2
  }
  "owners" : ["dl1abc","dh3wr","dl2ic"],
  "groups" : ["dl-hh", "dl-all"],
  "emergency_power": {
    "available": false,
    "infinite": false,
    "duration": 23*60*60 // seconds
  },
  "created_on": "2018-07-03T08:00:52.786458Z",
  "created_by": "dh3wr",
  "changed_on": "2018-07-03T08:00:52.786458Z",
  "changed_by": "dh3wr",
  "aprs_broadcast": false,
  "antenna_pattern" : <couchDB attachment>,
  "avatar_picture" : <couchDB attachment>
}
\end{lstlisting}


\subsection{Subscribers}
\label{protocoldef:couchdb:subscribers}
\todo{check if [] is valid JSON}
\textbf{If type is "Skyper", function is always 3. Keep this in mind }
\begin{lstlisting}
{
  "_id" : "dl1abc",
  "description" : "Peter",
  "pagers" : [
    {
      "ric": 123456,
      "function": 0 .. 3,
      "uuid": "0023-1233-aefe-1234-3423-9812",
      "name": "Peters Alphapoc",
      "type" : "UNKNOWN" | "Skyper" | "AlphaPoc" | "QUIX" | "Swissphone" | "SCALL_XT" | "Birdy"
      "enabled" : true
    },
    ...
  ],
  "third_party_services" : ["APRS", "BM"],
  "owner": ["dh3wr", "dl1abc"]
}
\end{lstlisting}

\subsection{Subscriber Groups}

\begin{lstlisting}
{
  "_id" : "ov-G01",
  "description": "Ortverband Aachen",
  "subscribers": ["dl1abc", "dh3wr"],
  "owner": ["dh3wr", "dl1abc"],
}
\end{lstlisting}

\subsection{Rubrics List}
\label{rubric_list}

\begin{lstlisting}
{
  "_id": "wx-dl-hh"
  "number": 14,
  "description": "Wetter DL-HH",
  "label": "WX DL-HH",
  "transmitter_groups": ["dl-hh","dl-ns"],
  "transmitters": ["db0abc"],
  "cyclic_transmit": true,
  "cyclic_transmit_interval": 60*60, // seconds
  "owner" : ["dh3wr", "dl1abc"]
}
\end{lstlisting}

\subsection{Rubric's content}
<UUID> of rubric (as defined in \ref{rubric_list})

\begin{lstlisting}
{
  "_id" : "<UUID>",
  "rubric": "wx-dl-hh",
  "content": [
    "message1",
    ..,
    "message10"
  ],
}
\end{lstlisting}

\subsection{MQTT services and subscribers}
\label{protocoldef:couchdb:mqttservicesandsubscribers}
\begin{lstlisting}
{
  "_id": "APRS",
  "topic": "aprs"
  "subscribers": [
    {
      "name": "example",
      "password": "<bcrypt hash>"
    },
    ...
  ]
}
\end{lstlisting}
