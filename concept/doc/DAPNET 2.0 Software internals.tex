\documentclass[a4paper]{article}

%% Language and font encodings
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}

%% Sets page size and margins
\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

%% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{listings,xcolor}
\usepackage{graphicx} 

\setlength{\parindent}{0pt}
\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}

\lstset{
  basicstyle=\footnotesize\ttfamily,
  string=[s]{"}{"},
  stringstyle=\color{blue},
  comment=[l]{:},
  commentstyle=\color{black},
}

\title{DAPNET 2.0 Concept and Interface Definition}
\author{
Ralf Wilke, DH3WR\\
Thomas Gatzweiler, DL2IC\\
Phillip Thiel, DL6PT
}

\begin{document}
\maketitle
\begin{abstract}
This is the concept and interface description of the version 2 of the DAPNET. It's purpose in comparison to the first version released is a more robust clustering and network interaction solution to cope with the special requirements of IP connections over HAMNET which means that all network connections have to be considered with a WAN character resulting in unreliable network connectivity. In terms of consistence of the database, "eventually consistence" is considered to be the most reachable. There are "always right" database nodes inside the so called HAMCLOUD. In case of database conflicts, the version inside the HAMCLOUD cluster is always to be considered right.
\end{abstract}

\section{Introduction}
\todo{write some history}
\section{Concept presentation}
An overview of the DAPNET 2.0 concept is given in Fig. \ref{fig:concept_overview}.

\begin{figure}[htbp] 
  \centering
     \includegraphics[width=0.8\textwidth]{{"assets/Concept Version 2.0 Overview"}.png}
  \caption{Overview of DAPNET Clutering and Network Structure}
  \label{fig:concept_overview}
\end{figure}

The details of a single node implementation are shown in Fig. \ref{fig:node_details}.
\begin{figure}[htbp] 
  \centering
     \includegraphics[width=0.8\textwidth]{{"assets/Concept Version 2.0 Node Details"}.png}
  \caption{Node Details}
  \label{fig:concept_overview}
\end{figure}


\subsection{HAMCLOUD presentation}
The HAMCLOUD is a virtual server combination to server central services on the HAMNET and provide short hop connectivity to deployed service on HAMNET towards the Internet. There are three data centers at Essen, Nürnberg and Aachen, which have high bandwidth interlinks over the DFN. There are address spaces for uni- and anycast services. How this concept is deployed is still tbd.
\todo{Define if uni- or anycast entry points will exist}
More information is here \url{https://www.swiss-artg.ch/fileadmin/Dokumente/HAMNET/HamCloud_-_Angebotene_Dienste_in_der_HamCloud.pdf} and here \url{http://hamnetdb.net/?m=as&q=hamcloud}.

\section{Functionality definition of Nodes}

\subsection{CouchDB and RabbitMQ distributed infrastructure}
\todo{DL2IC: Was dazu schreiben, Auf Unterschied HAMCLOUD oder nicht-HAMCLOUD Instanz eingehen}

\subsection{Node Details Overview}
A node instance consists of several micro-services. The graphic repesentation is given in Fig. \ref{fig:node_details}. This paragraph describes each part of a node.

\subsubsection{Stats and Websocket Micro-Service}

\textbf{Websocket}
The idea is to provide an API for the website and the app to display real-time information without the need of polling. A websocket server is listing to websocket connections. Authentication is done by a custom JOSN handshake. The connection might be encrypted with SSL if using the Internet or plain if using HAMNET. The definition of the protocol and valid data is given in section \ref{sec:websocket_api_definition}.

\section{Processes and Workflows}

\subsection{Website and App}
The website or the App has to follow the following processes in order to show real-time data of the network:

\subsubsection{Add, Edit, Delete and Show Transmitters}
\textbf{Show current status}
\begin{enumerate}
	\item Get 
\end{enumerate}

\subsubsection{Show Nodes}
\todo{machen wir hier auch auth?}

\subsubsection{Add, Edit, Delete and Show Users}
\textbf{Show current users}
\begin{enumerate}
	\item Get current status via REST GET to /users on Core URL
	\item Handle updates via Websocket
\end{enumerate}

\textbf{Add and Edit User}
\begin{enumerate}
	\item If edit: Get current status via REST GET to /users/<username> on Core URL
	\item Show edit form and place data
	\item On save button event, send REST POST to /users/<username> on Core URL
\end{enumerate}
The core will update the CouchDB and generate a RabbitMQ administration message to inform all other nodes. This information is transmitted by the Stats and Websocket Micro-Service to all connected websocket clients to get them updated. This will also happen for the website instance emitting the edit request, so its content is also updated.


\textbf{Delete User}
\begin{enumerate}
	\item Ask "Are you sure?"
	\item If yes, sent REST DELETE to /users/<username> on Core URL
\end{enumerate}
The core will update the CouchDB and generate a RabbitMQ administration message to inform all other nodes. This information is transmitted by the Stats and Websocket Micro-Service to all connected websocket clients to get them updated. This will also happen for the website instance emitting the edit request, so its content is also updated.


\subsubsection{Add, Edit, Delete and Show Rubric configuration}
\textbf{Show current configuration}
\begin{enumerate}
	\item Get current status via REST GET to /rubrics on Core URL
	\item Handle updates via websocket
\end{enumerate}

\textbf{Add and Edit rubrics}
\begin{enumerate}
	\item If edit: Get current status via REST GET to /rubrics/<rubricname> on Core URL
	\item Show edit form and place data
	\item On save button event, send REST POST to /users/<rubricname> on Core URL
\end{enumerate}
The core will update the CouchDB and generate a RabbitMQ administration message to inform all other nodes. This information is transmitted by the Stats and Websocket Micro-Service to all connected websocket clients to get them updated. This will also happen for the website instance emitting the edit request, so its content is also updated.


\textbf{Delete rubric}
\begin{enumerate}
	\item Ask "Are you sure?"
	\item If yes, sent REST DELETE to /users/<rubricname> on Core URL
\end{enumerate}
The core will update the CouchDB and generate a RabbitMQ administration message to inform all other nodes. This information is transmitted by the Stats and Websocket Micro-Service to all connected websocket clients to get them updated. This will also happen for the website instance emitting the edit request, so its content is also updated.




\section{Transmitter connections}

\subsection{Transmitter sign-in, configuration and keep-alive}
If a transmitter wants to connect to DAPNET, the first step is to sign-in and show it's presence via a REST interface. This interface is also used for transmitter configuration like enabled timeslots and keep-alive polling.

\subsection{Authentication of all HTTP-Requests in this context}
All HTTP-requests issued from a transmitter have to send a valid HTTP authentication, which is checked against the CouchDB. It consists of the transmitter name and its AuthKey.


\subsection{Initial contact}

\texttt{POST /transmitter/bootstrap}
\begin{lstlisting}
{
  "callsign": "db0avr",
  "auth_key": "<secret>",
  "software": {
    "name": "UniPager",
    "version": "1.0.2"
  }
}
\end{lstlisting}

\subsection{Answers to the bootstrap REST call}

\texttt{200 OK}
\begin{lstlisting}
{
  "timeslots": [true, true, false, true, ...],
  "nodes": [
    {
      "host": "node1.ampr.org",
      "port": 4000,
      "reachable": true,
      "last_seen": "2018-07-03T07:43:52.783611Z",
      "response_time": 42
    }
  ]
}
\end{lstlisting}

\texttt{423 Locked}
\begin{lstlisting}
{
  "error": "Transmitter temporarily disabled by config."
}
\end{lstlisting}

\texttt{423 Locked}
\begin{lstlisting}
{
  "error": "Transmitter software type not allowed due to serious bug."
}
\end{lstlisting}


\subsection{Transmitter Heartbeat}
\texttt{POST /transmitter/heartbeat}
\begin{lstlisting}
{
  "callsign": "db0avr",
  "auth_key": "<secret>",
  "ntp_synced": true
}
\end{lstlisting}

\subsubsubsection{Answers to the heartbeat REST call}
\texttt{200 OK}
\begin{lstlisting}
{
  "status": "ok"
}
\end{lstlisting}

If network wants to assign new timeslots without disconnecting (for dynamic timeslots)

\texttt{200 OK}
\begin{lstlisting}
{
  "status": "ok",
  "timeslots": [true, true, false, ...],
  "valid_from": "2018-07-03T08:00:52.786458Z"
}
\end{lstlisting}

If network wants to initiate handover to other node

\texttt{503 Service unavailable}
\begin{lstlisting}
{
  "error": "Node not available, switch to other node."
}
\end{lstlisting}

\subsection{Data delivery to Transmitter via RabbitMQ}



\section{Websocket API Definition}
\label{sec:websocket_api_definition}
When connecting to the websocket server, first authentication has to be done by an authentication message by the browser right after connection. This procedure is the same as used in unipager.

\subsubsection{Check authentication status}
\todo{DL2IC: Könntest du das ergänzen?}

\subsubsection{Get current status from Node via REST GET}
The current status (transmitter

\section{Real-Time update messages definition}
On the RabbitMQ exchange \textit{dapnet.telemetry} and \textit{dapnet.administration} as well on the websocket API, the following messages are used. The updates can be send combined in one message of each message separately. In any case, the \textit{transmittername} has to be sent to identify about what transmitter the data is.

\subsection{Transmitter TX Status}
\begin{lstlisting}
{
    "name": "db0acb",
    "transmitterupdate" : {
        "status" : {
            "OnAir" : true
        }
    }
}
\end{lstlisting}


\subsection{Configuration}
\begin{lstlisting}
{
    "name": "db0acb",
	"transmitterupdate" : {
		"status" : {
			"ConfiguredIP": "123.4.3.2",
            "timeslots" : [true, false,...,	false],
			"SoftwareType" : "Unipager" | "MMDVM" | "DAPNET-Proxy",
            "SoftwareVersion" : "v1.2.3", | "20180504" | "v2.3.4",
			"CPUHardwareType" : "Raspberry Pi 3B+"
			"RFHardware" : {
				"C9000" : {

					"UnipagerPowered" : true,
					"ArduinoPADummy" : true,
					"ArduinoPADummySettinginWatts" : 123,
					"ArduinoPADummyPort" : "/devttyUSB0"
or
					"RPC-CardPowered" : false,
					"RPC-Version" : "XOS/2.23pre",
                },
                "Raspager" : {
                    "RaspagerMod" : 13,
                    "RaspagerPower" : 63,
                    "ExternalPowerAmplifier": false,
                    "RaspagerRFVersion" : "V2"
                },
                "Audio" : {
                    "TXModel" : ["GM1200", "T7F", "GM340", "FREITEXT"],
                    "AudioLevelUnipager" : 83,
                    "TxDelayinMilliseconds" : 3
                }
                "RFM69" : {
                	"Port" : "/dev/ttyUSB0"
                },
                "MMDVM DualHS..." : {
                    "DAPNETExclusive" : true
                }
            },
            "DAPNET_Proxy" : {
                "ConnectionStatus" : "connected",
                "ConnectionStatus" : "connecting",
                "ConnectionStatus" : "disconnected"
            }
        }
    }
}
\end{lstlisting}


\subsection{Telemetry}
Sent every minute complete. If there are changes, just a subset is sent.
\begin{lstlisting}
{
    "name": "db0acb",
    "Telemetry" : {
        "ConnectionStatus": {
            "Connected" : true,
            "ConnectedtoNodeName" : "db0xyz"
            "ConnectedtoNodeIP" : "1.2.3.4"
            "ConnectedtoNodePort" : 1234
            "ConnectedSince" : "<timestamp-format>",
	    	"NTPSynced" : true,
            "NTPOffestMilliseconds" : 124
            "NTPServerUsedIP" : ["134.130.4.1", "12.2.3.2"]
        }
    },
    "QueueStatus" : {
        "Telemetry" : {
            "QueuedMessages" : {
                "Total" : 1234,
                "Prio1": 1234,
                "Prio2": 1234,
                "Prio3": 1234,
                "Prio4": 1234,
                "Prio5": 1234,
                "Prio10": 1234
        },
        "PrefinedTemperatures" : {
            "Unit" : "C",
or
            "Unit" : "F",
or
            "Unit" : "K",
         
            "AirInlet" : 12.2,
            "AirOutlet" : 14.2,
            "Transmitter" : 42.2,
            "PowerAmplifier" : 45.2,
            "CPU" : 93.2,
            "PowerSupply" : 32.4
        },
        "CustomTemperatures" : {
            "Unit" : "C",
or
            "Unit" : "F",
or
            "Unit" : "K",
            [
                {"Value" : 12.2, "Description" : "Aircon Inlet"},
                {"Value" : 16.2, "Description" : "Aircon Outlet"},
                {"Value" : 12.3, "Description" : "Fridge Next to Programmer"}
            ],
        },
        "PowerSupply" : {
            "OnBattery": false,
            "OnEmergencyPower": false,
            "DCInputVoltage" : 12.4,
            "DCInputCurrent" : 3.23
        },
        "RFoutput" : {
            "OutputPowerForwardinWatts": 12.2,
            "OutputPowerReturninWatts" : 12.2,
            "OutputVSWR" : 1.2
        }
    }
}
\end{lstlisting}


\section{CouchDB Document Structure}

\subsection{Users}

\begin{lstlisting}
{
	"_id": "dl1abc",
	"password": "some hash",
    "email": "user@example.com",
    "admin": true,
    "enabled":true,
    "created_on":<DATETIME>,
    "last_change_by":"dh3wr",
    "email_valid":true
    "avatar_picture": <couchdb attachment??>
}
\end{lstlisting}

\subsection{Nodes}
\begin{lstlisting}
{
	"_id" : "db0abc",
	"status" : "OFFLINE" | "ONLINE" | "ERROR",
	"last_update" : DATETIME,
    "version" : "1.2.3",
    "ip_address" : "1.2.3.4",
    "latitude" : 34.123456,
    "longitude" : -23.123456,
    "hamcloudnode" : true,
    "owners" : ["dl1abc","dh3wr","dl2ic"],
    "avatar_picture": <couchdb attachment??>
}
\end{lstlisting}

\subsection{Transmitters}

\begin{lstlisting}
{
	"_id" : "db0abc",
    "auth_keys" : "hdjaskhdlj",
    "enabled" : true,
	"status" : "UNKNOWN" | "OFFLINE" | "ONLINE",
	"site_type" : "PERSONAL" | "WIDERANGE",
	"aprs_reporting_enabled" : true,
    "last_update" : "<DATETIME>",
	"ast_connect" : "<DATETIME>",
	"connected_since" : "<DATETIME>",
    "ip_address" : "1.2.3.4",
    "device_type" : "Unipager",
    "device_version" : "1.3.2",
    "latitude" : 23.123456,
    "longitude" : -31.123456
    "rf_power_watt": 12.3,
    "cable_loss_db" : 4.2,
    "antenna_gain_dbi" : 2.34,
	"antenna_agl_m" : 23.4,
	"antenna_type" : "OMNI" | "DIRECTIONAL",
	"antenna_direction" : 123.2,
    "owners" : ["dl1abc","dh3wr","dl2ic"],
    "groups" : ["dl-hh", "dl-all"],
    "frequency_MHz" : 439.9875,
    "emergency_power_available" : false,
    "infinite_emergency_power" : false,
	"emergency_power_duration_hours" : 23.0        
    "antenna_pattern" : <couchDB attachment>,
    "avatar_picture" : <couchDB attachment>
}
\end{lstlisting}

 
\subsection{Subscribers}
\todo{check if [] is valid JSON}
\begin{lstlisting}
{
	"_id" : "dl1abc",
	"description" : "Peter",
	"pagers" : [
		{
    		"ric" : {123456, "A"} ... "ric" : {123456, "D"},

			"uuid" : "0023-1233-aefe-1234-3423-9812",
    		"name" : "Peters Alphapoc",

			"type" : "UNKNOWN" | "Skyper" | "AlphaPoc" | "QUIX" | "Swissphone" | "SCALL_XT" | "Birdy"

			"is_enabled" : true
     	},
     	...
     ],
    "owner" : ["dh3wr", "dl1abc"]
}
\end{lstlisting}

\subsection{Subscriber Groups}

\begin{lstlisting}
{
	"_id" : "ov-G01",
	"description" : "Ortverband Aachen",
	"member_subscribers" : ["dl1abc", "dh3wr"],
    "owner" : ["dh3wr", "dl1abc"],
}
\end{lstlisting}

\subsection{Rubrics List}
\label{rubric_list}

\begin{lstlisting}
{
   	"uuid" : "<UUID>"
    "number" : 14,
    "description" : "Wetter DL-HH",
    "label" : "WX DL-HH",
    "transmitter_groups" : ["dl-hh","dl-ns"],
    "transmitters" : ["db0abc"],
	"cyclic_transmit_enabled" : true,
    "cyclic_transmit_interval_minutes": 123,
 	"owner" : ["dh3wr", "dl1abc"]
}
\end{lstlisting}

\subsection{Rubric's content}
<UUID> of rubric (as defined in \ref{rubric_list})

\begin{lstlisting}
{
	"uuid" : "<UUID>",
	["content_message1",..,"content_message10"],
}
\end{lstlisting}

\end{document}
